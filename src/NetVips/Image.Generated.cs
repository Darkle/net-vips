//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     libvips version: 8.10.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NetVips
{
    using System.IO;

    public sealed partial class Image
    {
        #region auto-generated functions

        /// <summary>
        /// Absolute value of an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Abs();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Abs()
        {
            return this.Call("abs") as Image;
        }

        /// <summary>
        /// Add two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Add(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Add(Image right)
        {
            return this.Call("add", right) as Image;
        }

        /// <summary>
        /// Affine transform of an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Affine(matrix, interpolate: GObject, oarea: int[], odx: double, ody: double, idx: double, idy: double, background: double[], premultiplied: bool, extend: string);
        /// </code>
        /// </example>
        /// <param name="matrix">Transformation matrix.</param>
        /// <param name="interpolate">Interpolate pixels with this.</param>
        /// <param name="oarea">Area of output to generate.</param>
        /// <param name="odx">Horizontal output displacement.</param>
        /// <param name="ody">Vertical output displacement.</param>
        /// <param name="idx">Horizontal input displacement.</param>
        /// <param name="idy">Vertical input displacement.</param>
        /// <param name="background">Background value.</param>
        /// <param name="premultiplied">Images have premultiplied alpha.</param>
        /// <param name="extend">How to generate the extra pixels.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Affine(double[] matrix, GObject interpolate = null, int[] oarea = null, double? odx = null, double? ody = null, double? idx = null, double? idy = null, double[] background = null, bool? premultiplied = null, string extend = null)
        {
            var options = new VOption();

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            if (oarea != null && oarea.Length > 0)
            {
                options.Add(nameof(oarea), oarea);
            }

            if (odx.HasValue)
            {
                options.Add(nameof(odx), odx);
            }

            if (ody.HasValue)
            {
                options.Add(nameof(ody), ody);
            }

            if (idx.HasValue)
            {
                options.Add(nameof(idx), idx);
            }

            if (idy.HasValue)
            {
                options.Add(nameof(idy), idy);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (premultiplied.HasValue)
            {
                options.Add(nameof(premultiplied), premultiplied);
            }

            if (extend != null)
            {
                options.Add(nameof(extend), extend);
            }

            return this.Call("affine", options, matrix) as Image;
        }

        /// <summary>
        /// Load an Analyze6 image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Analyzeload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Analyzeload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("analyzeload", options, filename) as Image;
        }

        /// <summary>
        /// Load an Analyze6 image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Analyzeload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Analyzeload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("analyzeload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Join an array of images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Arrayjoin(@in, across: int, shim: int, background: double[], halign: string, valign: string, hspacing: int, vspacing: int);
        /// </code>
        /// </example>
        /// <param name="in">Array of input images.</param>
        /// <param name="across">Number of images across grid.</param>
        /// <param name="shim">Pixels between images.</param>
        /// <param name="background">Colour for new pixels.</param>
        /// <param name="halign">Align on the left, centre or right.</param>
        /// <param name="valign">Align on the top, centre or bottom.</param>
        /// <param name="hspacing">Horizontal spacing between images.</param>
        /// <param name="vspacing">Vertical spacing between images.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Arrayjoin(Image[] @in, int? across = null, int? shim = null, double[] background = null, string halign = null, string valign = null, int? hspacing = null, int? vspacing = null)
        {
            var options = new VOption();

            if (across.HasValue)
            {
                options.Add(nameof(across), across);
            }

            if (shim.HasValue)
            {
                options.Add(nameof(shim), shim);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (halign != null)
            {
                options.Add(nameof(halign), halign);
            }

            if (valign != null)
            {
                options.Add(nameof(valign), valign);
            }

            if (hspacing.HasValue)
            {
                options.Add(nameof(hspacing), hspacing);
            }

            if (vspacing.HasValue)
            {
                options.Add(nameof(vspacing), vspacing);
            }

            return Operation.Call("arrayjoin", options, new object[] { @in }) as Image;
        }

        /// <summary>
        /// Autorotate image by exif tag.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Autorot();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Autorot()
        {
            return this.Call("autorot") as Image;
        }

        /// <summary>
        /// Autorotate image by exif tag.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Autorot(out var angle);
        /// </code>
        /// </example>
        /// <param name="angle">Angle image was rotated by.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Autorot(out string angle)
        {
            var optionalOutput = new VOption
            {
                {"angle", true}
            };

            var results = this.Call("autorot", optionalOutput) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            angle = opts?["angle"] is string out1 ? out1 : null;

            return finalResult;
        }

        /// <summary>
        /// Autorotate image by exif tag.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Autorot(out var angle, out var flip);
        /// </code>
        /// </example>
        /// <param name="angle">Angle image was rotated by.</param>
        /// <param name="flip">Whether the image was flipped or not.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Autorot(out string angle, out bool flip)
        {
            var optionalOutput = new VOption
            {
                {"angle", true},
                {"flip", true}
            };

            var results = this.Call("autorot", optionalOutput) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            angle = opts?["angle"] is string out1 ? out1 : null;
            flip = opts?["flip"] is bool out2 && out2;

            return finalResult;
        }

        /// <summary>
        /// Find image average.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Avg();
        /// </code>
        /// </example>
        /// <returns>A double.</returns>
        public double Avg()
        {
            return this.Call("avg") is double result ? result : 0d;
        }

        /// <summary>
        /// Boolean operation across image bands.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Bandbool(boolean);
        /// </code>
        /// </example>
        /// <param name="boolean">boolean to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Bandbool(string boolean)
        {
            return this.Call("bandbool", boolean) as Image;
        }

        /// <summary>
        /// Fold up x axis into bands.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Bandfold(factor: int);
        /// </code>
        /// </example>
        /// <param name="factor">Fold by this factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Bandfold(int? factor = null)
        {
            var options = new VOption();

            if (factor.HasValue)
            {
                options.Add(nameof(factor), factor);
            }

            return this.Call("bandfold", options) as Image;
        }

        /// <summary>
        /// Append a constant band to an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.BandjoinConst(c);
        /// </code>
        /// </example>
        /// <param name="c">Array of constants to add.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image BandjoinConst(double[] c)
        {
            return this.Call("bandjoin_const", c) as Image;
        }

        /// <summary>
        /// Band-wise average.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Bandmean();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Bandmean()
        {
            return this.Call("bandmean") as Image;
        }

        /// <summary>
        /// Unfold image bands into x axis.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Bandunfold(factor: int);
        /// </code>
        /// </example>
        /// <param name="factor">Unfold by this factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Bandunfold(int? factor = null)
        {
            var options = new VOption();

            if (factor.HasValue)
            {
                options.Add(nameof(factor), factor);
            }

            return this.Call("bandunfold", options) as Image;
        }

        /// <summary>
        /// Make a black image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Black(width, height, bands: int);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="bands">Number of bands in image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Black(int width, int height, int? bands = null)
        {
            var options = new VOption();

            if (bands.HasValue)
            {
                options.Add(nameof(bands), bands);
            }

            return Operation.Call("black", options, width, height) as Image;
        }

        /// <summary>
        /// Boolean operation on two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Boolean(right, boolean);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <param name="boolean">boolean to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Boolean(Image right, string boolean)
        {
            return this.Call("boolean", right, boolean) as Image;
        }

        /// <summary>
        /// Boolean operations against a constant.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.BooleanConst(boolean, c);
        /// </code>
        /// </example>
        /// <param name="boolean">boolean to perform.</param>
        /// <param name="c">Array of constants.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image BooleanConst(string boolean, double[] c)
        {
            return this.Call("boolean_const", boolean, c) as Image;
        }

        /// <summary>
        /// Build a look-up table.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Buildlut();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Buildlut()
        {
            return this.Call("buildlut") as Image;
        }

        /// <summary>
        /// Byteswap an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Byteswap();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Byteswap()
        {
            return this.Call("byteswap") as Image;
        }

        /// <summary>
        /// Cache an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Cache(maxTiles: int, tileHeight: int, tileWidth: int);
        /// </code>
        /// </example>
        /// <param name="maxTiles">Maximum number of tiles to cache.</param>
        /// <param name="tileHeight">Tile height in pixels.</param>
        /// <param name="tileWidth">Tile width in pixels.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Cache(int? maxTiles = null, int? tileHeight = null, int? tileWidth = null)
        {
            var options = new VOption();

            if (maxTiles.HasValue)
            {
                options.Add("max_tiles", maxTiles);
            }

            if (tileHeight.HasValue)
            {
                options.Add("tile_height", tileHeight);
            }

            if (tileWidth.HasValue)
            {
                options.Add("tile_width", tileWidth);
            }

            return this.Call("cache", options) as Image;
        }

        /// <summary>
        /// Canny edge detector.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Canny(sigma: double, precision: string);
        /// </code>
        /// </example>
        /// <param name="sigma">Sigma of Gaussian.</param>
        /// <param name="precision">Convolve with this precision.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Canny(double? sigma = null, string precision = null)
        {
            var options = new VOption();

            if (sigma.HasValue)
            {
                options.Add(nameof(sigma), sigma);
            }

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            return this.Call("canny", options) as Image;
        }

        /// <summary>
        /// Cast an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Cast(format, shift: bool);
        /// </code>
        /// </example>
        /// <param name="format">Format to cast to.</param>
        /// <param name="shift">Shift integer values up and down.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Cast(string format, bool? shift = null)
        {
            var options = new VOption();

            if (shift.HasValue)
            {
                options.Add(nameof(shift), shift);
            }

            return this.Call("cast", options, format) as Image;
        }

        /// <summary>
        /// Transform LCh to CMC.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.CMC2LCh();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image CMC2LCh()
        {
            return this.Call("CMC2LCh") as Image;
        }

        /// <summary>
        /// Transform CMYK to XYZ.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.CMYK2XYZ();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image CMYK2XYZ()
        {
            return this.Call("CMYK2XYZ") as Image;
        }

        /// <summary>
        /// Convert to a new colorspace.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Colourspace(space, sourceSpace: string);
        /// </code>
        /// </example>
        /// <param name="space">Destination color space.</param>
        /// <param name="sourceSpace">Source color space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Colourspace(string space, string sourceSpace = null)
        {
            var options = new VOption();

            if (sourceSpace != null)
            {
                options.Add("source_space", sourceSpace);
            }

            return this.Call("colourspace", options, space) as Image;
        }

        /// <summary>
        /// Convolve with rotating mask.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Compass(mask, times: int, angle: string, combine: string, precision: string, layers: int, cluster: int);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <param name="times">Rotate and convolve this many times.</param>
        /// <param name="angle">Rotate mask by this much between convolutions.</param>
        /// <param name="combine">Combine convolution results like this.</param>
        /// <param name="precision">Convolve with this precision.</param>
        /// <param name="layers">Use this many layers in approximation.</param>
        /// <param name="cluster">Cluster lines closer than this in approximation.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Compass(Image mask, int? times = null, string angle = null, string combine = null, string precision = null, int? layers = null, int? cluster = null)
        {
            var options = new VOption();

            if (times.HasValue)
            {
                options.Add(nameof(times), times);
            }

            if (angle != null)
            {
                options.Add(nameof(angle), angle);
            }

            if (combine != null)
            {
                options.Add(nameof(combine), combine);
            }

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            if (layers.HasValue)
            {
                options.Add(nameof(layers), layers);
            }

            if (cluster.HasValue)
            {
                options.Add(nameof(cluster), cluster);
            }

            return this.Call("compass", options, mask) as Image;
        }

        /// <summary>
        /// Perform a complex operation on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Complex(cmplx);
        /// </code>
        /// </example>
        /// <param name="cmplx">complex to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Complex(string cmplx)
        {
            return this.Call("complex", cmplx) as Image;
        }

        /// <summary>
        /// Complex binary operations on two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Complex2(right, cmplx);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <param name="cmplx">binary complex operation to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Complex2(Image right, string cmplx)
        {
            return this.Call("complex2", right, cmplx) as Image;
        }

        /// <summary>
        /// Form a complex image from two real images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Complexform(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Complexform(Image right)
        {
            return this.Call("complexform", right) as Image;
        }

        /// <summary>
        /// Get a component from a complex image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Complexget(get);
        /// </code>
        /// </example>
        /// <param name="get">complex to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Complexget(string get)
        {
            return this.Call("complexget", get) as Image;
        }

        /// <summary>
        /// Blend a pair of images with a blend mode.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = base.Composite2(overlay, mode, x: int, y: int, compositingSpace: string, premultiplied: bool);
        /// </code>
        /// </example>
        /// <param name="overlay">Overlay image.</param>
        /// <param name="mode">VipsBlendMode to join with.</param>
        /// <param name="x">x position of overlay.</param>
        /// <param name="y">y position of overlay.</param>
        /// <param name="compositingSpace">Composite images in this colour space.</param>
        /// <param name="premultiplied">Images have premultiplied alpha.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Composite2(Image overlay, string mode, int? x = null, int? y = null, string compositingSpace = null, bool? premultiplied = null)
        {
            var options = new VOption();

            if (x.HasValue)
            {
                options.Add(nameof(x), x);
            }

            if (y.HasValue)
            {
                options.Add(nameof(y), y);
            }

            if (compositingSpace != null)
            {
                options.Add("compositing_space", compositingSpace);
            }

            if (premultiplied.HasValue)
            {
                options.Add(nameof(premultiplied), premultiplied);
            }

            return this.Call("composite2", options, overlay, mode) as Image;
        }

        /// <summary>
        /// Convolution operation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Conv(mask, precision: string, layers: int, cluster: int);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <param name="precision">Convolve with this precision.</param>
        /// <param name="layers">Use this many layers in approximation.</param>
        /// <param name="cluster">Cluster lines closer than this in approximation.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Conv(Image mask, string precision = null, int? layers = null, int? cluster = null)
        {
            var options = new VOption();

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            if (layers.HasValue)
            {
                options.Add(nameof(layers), layers);
            }

            if (cluster.HasValue)
            {
                options.Add(nameof(cluster), cluster);
            }

            return this.Call("conv", options, mask) as Image;
        }

        /// <summary>
        /// Approximate integer convolution.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Conva(mask, layers: int, cluster: int);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <param name="layers">Use this many layers in approximation.</param>
        /// <param name="cluster">Cluster lines closer than this in approximation.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Conva(Image mask, int? layers = null, int? cluster = null)
        {
            var options = new VOption();

            if (layers.HasValue)
            {
                options.Add(nameof(layers), layers);
            }

            if (cluster.HasValue)
            {
                options.Add(nameof(cluster), cluster);
            }

            return this.Call("conva", options, mask) as Image;
        }

        /// <summary>
        /// Approximate separable integer convolution.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Convasep(mask, layers: int);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <param name="layers">Use this many layers in approximation.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Convasep(Image mask, int? layers = null)
        {
            var options = new VOption();

            if (layers.HasValue)
            {
                options.Add(nameof(layers), layers);
            }

            return this.Call("convasep", options, mask) as Image;
        }

        /// <summary>
        /// Float convolution operation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Convf(mask);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Convf(Image mask)
        {
            return this.Call("convf", mask) as Image;
        }

        /// <summary>
        /// Int convolution operation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Convi(mask);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Convi(Image mask)
        {
            return this.Call("convi", mask) as Image;
        }

        /// <summary>
        /// Seperable convolution operation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Convsep(mask, precision: string, layers: int, cluster: int);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <param name="precision">Convolve with this precision.</param>
        /// <param name="layers">Use this many layers in approximation.</param>
        /// <param name="cluster">Cluster lines closer than this in approximation.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Convsep(Image mask, string precision = null, int? layers = null, int? cluster = null)
        {
            var options = new VOption();

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            if (layers.HasValue)
            {
                options.Add(nameof(layers), layers);
            }

            if (cluster.HasValue)
            {
                options.Add(nameof(cluster), cluster);
            }

            return this.Call("convsep", options, mask) as Image;
        }

        /// <summary>
        /// Copy an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Copy(width: int, height: int, bands: int, format: string, coding: string, interpretation: string, xres: double, yres: double, xoffset: int, yoffset: int);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="bands">Number of bands in image.</param>
        /// <param name="format">Pixel format in image.</param>
        /// <param name="coding">Pixel coding.</param>
        /// <param name="interpretation">Pixel interpretation.</param>
        /// <param name="xres">Horizontal resolution in pixels/mm.</param>
        /// <param name="yres">Vertical resolution in pixels/mm.</param>
        /// <param name="xoffset">Horizontal offset of origin.</param>
        /// <param name="yoffset">Vertical offset of origin.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Copy(int? width = null, int? height = null, int? bands = null, string format = null, string coding = null, string interpretation = null, double? xres = null, double? yres = null, int? xoffset = null, int? yoffset = null)
        {
            var options = new VOption();

            if (width.HasValue)
            {
                options.Add(nameof(width), width);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (bands.HasValue)
            {
                options.Add(nameof(bands), bands);
            }

            if (format != null)
            {
                options.Add(nameof(format), format);
            }

            if (coding != null)
            {
                options.Add(nameof(coding), coding);
            }

            if (interpretation != null)
            {
                options.Add(nameof(interpretation), interpretation);
            }

            if (xres.HasValue)
            {
                options.Add(nameof(xres), xres);
            }

            if (yres.HasValue)
            {
                options.Add(nameof(yres), yres);
            }

            if (xoffset.HasValue)
            {
                options.Add(nameof(xoffset), xoffset);
            }

            if (yoffset.HasValue)
            {
                options.Add(nameof(yoffset), yoffset);
            }

            return this.Call("copy", options) as Image;
        }

        /// <summary>
        /// Count lines in an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double nolines = in.Countlines(direction);
        /// </code>
        /// </example>
        /// <param name="direction">Countlines left-right or up-down.</param>
        /// <returns>A double.</returns>
        public double Countlines(string direction)
        {
            return this.Call("countlines", direction) is double result ? result : 0d;
        }

        /// <summary>
        /// Load csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Csvload(filename, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="skip">Skip this many lines at the start of the file.</param>
        /// <param name="lines">Read this many lines from the file.</param>
        /// <param name="whitespace">Set of whitespace characters.</param>
        /// <param name="separator">Set of separator characters.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Csvload(string filename, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (skip.HasValue)
            {
                options.Add(nameof(skip), skip);
            }

            if (lines.HasValue)
            {
                options.Add(nameof(lines), lines);
            }

            if (whitespace != null)
            {
                options.Add(nameof(whitespace), whitespace);
            }

            if (separator != null)
            {
                options.Add(nameof(separator), separator);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("csvload", options, filename) as Image;
        }

        /// <summary>
        /// Load csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Csvload(filename, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="skip">Skip this many lines at the start of the file.</param>
        /// <param name="lines">Read this many lines from the file.</param>
        /// <param name="whitespace">Set of whitespace characters.</param>
        /// <param name="separator">Set of separator characters.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Csvload(string filename, out int flags, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (skip.HasValue)
            {
                options.Add(nameof(skip), skip);
            }

            if (lines.HasValue)
            {
                options.Add(nameof(lines), lines);
            }

            if (whitespace != null)
            {
                options.Add(nameof(whitespace), whitespace);
            }

            if (separator != null)
            {
                options.Add(nameof(separator), separator);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("csvload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.CsvloadSource(source, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="skip">Skip this many lines at the start of the file.</param>
        /// <param name="lines">Read this many lines from the file.</param>
        /// <param name="whitespace">Set of whitespace characters.</param>
        /// <param name="separator">Set of separator characters.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image CsvloadSource(Source source, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (skip.HasValue)
            {
                options.Add(nameof(skip), skip);
            }

            if (lines.HasValue)
            {
                options.Add(nameof(lines), lines);
            }

            if (whitespace != null)
            {
                options.Add(nameof(whitespace), whitespace);
            }

            if (separator != null)
            {
                options.Add(nameof(separator), separator);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("csvload_source", options, source) as Image;
        }

        /// <summary>
        /// Load csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.CsvloadStream(stream, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="skip">Skip this many lines at the start of the file.</param>
        /// <param name="lines">Read this many lines from the file.</param>
        /// <param name="whitespace">Set of whitespace characters.</param>
        /// <param name="separator">Set of separator characters.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image CsvloadStream(Stream stream, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = CsvloadSource(source, skip, lines, whitespace, separator, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.CsvloadSource(source, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="skip">Skip this many lines at the start of the file.</param>
        /// <param name="lines">Read this many lines from the file.</param>
        /// <param name="whitespace">Set of whitespace characters.</param>
        /// <param name="separator">Set of separator characters.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image CsvloadSource(Source source, out int flags, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (skip.HasValue)
            {
                options.Add(nameof(skip), skip);
            }

            if (lines.HasValue)
            {
                options.Add(nameof(lines), lines);
            }

            if (whitespace != null)
            {
                options.Add(nameof(whitespace), whitespace);
            }

            if (separator != null)
            {
                options.Add(nameof(separator), separator);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("csvload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.CsvloadStream(stream, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="skip">Skip this many lines at the start of the file.</param>
        /// <param name="lines">Read this many lines from the file.</param>
        /// <param name="whitespace">Set of whitespace characters.</param>
        /// <param name="separator">Set of separator characters.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image CsvloadStream(Stream stream, out int flags, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = CsvloadSource(source, out flags, skip, lines, whitespace, separator, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Csvsave(filename, separator: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="separator">Separator characters.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Csvsave(string filename, string separator = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (separator != null)
            {
                options.Add(nameof(separator), separator);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("csvsave", options, filename);
        }

        /// <summary>
        /// Save image to csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.CsvsaveTarget(target, separator: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="separator">Separator characters.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void CsvsaveTarget(Target target, string separator = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (separator != null)
            {
                options.Add(nameof(separator), separator);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("csvsave_target", options, target);
        }

        /// <summary>
        /// Save image to csv.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.CsvsaveStream(stream, separator: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="separator">Separator characters.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void CsvsaveStream(Stream stream, string separator = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                CsvsaveTarget(target, separator, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Calculate dE00.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.DE00(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand input image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DE00(Image right)
        {
            return this.Call("dE00", right) as Image;
        }

        /// <summary>
        /// Calculate dE76.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.DE76(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand input image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DE76(Image right)
        {
            return this.Call("dE76", right) as Image;
        }

        /// <summary>
        /// Calculate dECMC.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.DECMC(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand input image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DECMC(Image right)
        {
            return this.Call("dECMC", right) as Image;
        }

        /// <summary>
        /// Find image standard deviation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Deviate();
        /// </code>
        /// </example>
        /// <returns>A double.</returns>
        public double Deviate()
        {
            return this.Call("deviate") is double result ? result : 0d;
        }

        /// <summary>
        /// Divide two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Divide(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Divide(Image right)
        {
            return this.Call("divide", right) as Image;
        }

        /// <summary>
        /// Draw a circle on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawCircle(ink, cx, cy, radius, fill: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="cx">Centre of draw_circle.</param>
        /// <param name="cy">Centre of draw_circle.</param>
        /// <param name="radius">Radius in pixels.</param>
        /// <param name="fill">Draw a solid object.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawCircle(double[] ink, int cx, int cy, int radius, bool? fill = null)
        {
            var options = new VOption();

            if (fill.HasValue)
            {
                options.Add(nameof(fill), fill);
            }

            return this.Call("draw_circle", options, ink, cx, cy, radius) as Image;
        }

        /// <summary>
        /// Flood-fill an area.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawFlood(ink, x, y, test: Image, equal: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="x">DrawFlood start point.</param>
        /// <param name="y">DrawFlood start point.</param>
        /// <param name="test">Test pixels in this image.</param>
        /// <param name="equal">DrawFlood while equal to edge.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawFlood(double[] ink, int x, int y, Image test = null, bool? equal = null)
        {
            var options = new VOption();

            if (test != null)
            {
                options.Add(nameof(test), test);
            }

            if (equal.HasValue)
            {
                options.Add(nameof(equal), equal);
            }

            return this.Call("draw_flood", options, ink, x, y) as Image;
        }

        /// <summary>
        /// Flood-fill an area.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawFlood(ink, x, y, out var left, test: Image, equal: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="x">DrawFlood start point.</param>
        /// <param name="y">DrawFlood start point.</param>
        /// <param name="left">Left edge of modified area.</param>
        /// <param name="test">Test pixels in this image.</param>
        /// <param name="equal">DrawFlood while equal to edge.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawFlood(double[] ink, int x, int y, out int left, Image test = null, bool? equal = null)
        {
            var options = new VOption();

            if (test != null)
            {
                options.Add(nameof(test), test);
            }

            if (equal.HasValue)
            {
                options.Add(nameof(equal), equal);
            }

            options.Add("left", true);

            var results = this.Call("draw_flood", options, ink, x, y) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            left = opts?["left"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Flood-fill an area.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawFlood(ink, x, y, out var left, out var top, test: Image, equal: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="x">DrawFlood start point.</param>
        /// <param name="y">DrawFlood start point.</param>
        /// <param name="left">Left edge of modified area.</param>
        /// <param name="top">top edge of modified area.</param>
        /// <param name="test">Test pixels in this image.</param>
        /// <param name="equal">DrawFlood while equal to edge.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawFlood(double[] ink, int x, int y, out int left, out int top, Image test = null, bool? equal = null)
        {
            var options = new VOption();

            if (test != null)
            {
                options.Add(nameof(test), test);
            }

            if (equal.HasValue)
            {
                options.Add(nameof(equal), equal);
            }

            options.Add("left", true);
            options.Add("top", true);

            var results = this.Call("draw_flood", options, ink, x, y) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            left = opts?["left"] is int out1 ? out1 : 0;
            top = opts?["top"] is int out2 ? out2 : 0;

            return finalResult;
        }

        /// <summary>
        /// Flood-fill an area.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawFlood(ink, x, y, out var left, out var top, out var width, test: Image, equal: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="x">DrawFlood start point.</param>
        /// <param name="y">DrawFlood start point.</param>
        /// <param name="left">Left edge of modified area.</param>
        /// <param name="top">top edge of modified area.</param>
        /// <param name="width">width of modified area.</param>
        /// <param name="test">Test pixels in this image.</param>
        /// <param name="equal">DrawFlood while equal to edge.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawFlood(double[] ink, int x, int y, out int left, out int top, out int width, Image test = null, bool? equal = null)
        {
            var options = new VOption();

            if (test != null)
            {
                options.Add(nameof(test), test);
            }

            if (equal.HasValue)
            {
                options.Add(nameof(equal), equal);
            }

            options.Add("left", true);
            options.Add("top", true);
            options.Add("width", true);

            var results = this.Call("draw_flood", options, ink, x, y) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            left = opts?["left"] is int out1 ? out1 : 0;
            top = opts?["top"] is int out2 ? out2 : 0;
            width = opts?["width"] is int out3 ? out3 : 0;

            return finalResult;
        }

        /// <summary>
        /// Flood-fill an area.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawFlood(ink, x, y, out var left, out var top, out var width, out var height, test: Image, equal: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="x">DrawFlood start point.</param>
        /// <param name="y">DrawFlood start point.</param>
        /// <param name="left">Left edge of modified area.</param>
        /// <param name="top">top edge of modified area.</param>
        /// <param name="width">width of modified area.</param>
        /// <param name="height">height of modified area.</param>
        /// <param name="test">Test pixels in this image.</param>
        /// <param name="equal">DrawFlood while equal to edge.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawFlood(double[] ink, int x, int y, out int left, out int top, out int width, out int height, Image test = null, bool? equal = null)
        {
            var options = new VOption();

            if (test != null)
            {
                options.Add(nameof(test), test);
            }

            if (equal.HasValue)
            {
                options.Add(nameof(equal), equal);
            }

            options.Add("left", true);
            options.Add("top", true);
            options.Add("width", true);
            options.Add("height", true);

            var results = this.Call("draw_flood", options, ink, x, y) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            left = opts?["left"] is int out1 ? out1 : 0;
            top = opts?["top"] is int out2 ? out2 : 0;
            width = opts?["width"] is int out3 ? out3 : 0;
            height = opts?["height"] is int out4 ? out4 : 0;

            return finalResult;
        }

        /// <summary>
        /// Paint an image into another image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawImage(sub, x, y, mode: string);
        /// </code>
        /// </example>
        /// <param name="sub">Sub-image to insert into main image.</param>
        /// <param name="x">Draw image here.</param>
        /// <param name="y">Draw image here.</param>
        /// <param name="mode">Combining mode.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawImage(Image sub, int x, int y, string mode = null)
        {
            var options = new VOption();

            if (mode != null)
            {
                options.Add(nameof(mode), mode);
            }

            return this.Call("draw_image", options, sub, x, y) as Image;
        }

        /// <summary>
        /// Draw a line on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawLine(ink, x1, y1, x2, y2);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="x1">Start of draw_line.</param>
        /// <param name="y1">Start of draw_line.</param>
        /// <param name="x2">End of draw_line.</param>
        /// <param name="y2">End of draw_line.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawLine(double[] ink, int x1, int y1, int x2, int y2)
        {
            return this.Call("draw_line", ink, x1, y1, x2, y2) as Image;
        }

        /// <summary>
        /// Draw a mask on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawMask(ink, mask, x, y);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="mask">Mask of pixels to draw.</param>
        /// <param name="x">Draw mask here.</param>
        /// <param name="y">Draw mask here.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawMask(double[] ink, Image mask, int x, int y)
        {
            return this.Call("draw_mask", ink, mask, x, y) as Image;
        }

        /// <summary>
        /// Paint a rectangle on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawRect(ink, left, top, width, height, fill: bool);
        /// </code>
        /// </example>
        /// <param name="ink">Color for pixels.</param>
        /// <param name="left">Rect to fill.</param>
        /// <param name="top">Rect to fill.</param>
        /// <param name="width">Rect to fill.</param>
        /// <param name="height">Rect to fill.</param>
        /// <param name="fill">Draw a solid object.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawRect(double[] ink, int left, int top, int width, int height, bool? fill = null)
        {
            var options = new VOption();

            if (fill.HasValue)
            {
                options.Add(nameof(fill), fill);
            }

            return this.Call("draw_rect", options, ink, left, top, width, height) as Image;
        }

        /// <summary>
        /// Blur a rectangle on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image image = image.DrawSmudge(left, top, width, height);
        /// </code>
        /// </example>
        /// <param name="left">Rect to fill.</param>
        /// <param name="top">Rect to fill.</param>
        /// <param name="width">Rect to fill.</param>
        /// <param name="height">Rect to fill.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image DrawSmudge(int left, int top, int width, int height)
        {
            return this.Call("draw_smudge", left, top, width, height) as Image;
        }

        /// <summary>
        /// Save image to deepzoom file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Dzsave(filename, basename: string, layout: string, suffix: string, overlap: int, tileSize: int, centre: bool, depth: string, angle: string, container: string, properties: bool, compression: int, regionShrink: string, skipBlanks: int, noStrip: bool, id: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="basename">Base name to save to.</param>
        /// <param name="layout">Directory layout.</param>
        /// <param name="suffix">Filename suffix for tiles.</param>
        /// <param name="overlap">Tile overlap in pixels.</param>
        /// <param name="tileSize">Tile size in pixels.</param>
        /// <param name="centre">Center image in tile.</param>
        /// <param name="depth">Pyramid depth.</param>
        /// <param name="angle">Rotate image during save.</param>
        /// <param name="container">Pyramid container type.</param>
        /// <param name="properties">Write a properties file to the output directory.</param>
        /// <param name="compression">ZIP deflate compression level.</param>
        /// <param name="regionShrink">Method to shrink regions.</param>
        /// <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
        /// <param name="noStrip">Don't strip tile metadata.</param>
        /// <param name="id">Resource ID.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Dzsave(string filename, string basename = null, string layout = null, string suffix = null, int? overlap = null, int? tileSize = null, bool? centre = null, string depth = null, string angle = null, string container = null, bool? properties = null, int? compression = null, string regionShrink = null, int? skipBlanks = null, bool? noStrip = null, string id = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (basename != null)
            {
                options.Add(nameof(basename), basename);
            }

            if (layout != null)
            {
                options.Add(nameof(layout), layout);
            }

            if (suffix != null)
            {
                options.Add(nameof(suffix), suffix);
            }

            if (overlap.HasValue)
            {
                options.Add(nameof(overlap), overlap);
            }

            if (tileSize.HasValue)
            {
                options.Add("tile_size", tileSize);
            }

            if (centre.HasValue)
            {
                options.Add(nameof(centre), centre);
            }

            if (depth != null)
            {
                options.Add(nameof(depth), depth);
            }

            if (angle != null)
            {
                options.Add(nameof(angle), angle);
            }

            if (container != null)
            {
                options.Add(nameof(container), container);
            }

            if (properties.HasValue)
            {
                options.Add(nameof(properties), properties);
            }

            if (compression.HasValue)
            {
                options.Add(nameof(compression), compression);
            }

            if (regionShrink != null)
            {
                options.Add("region_shrink", regionShrink);
            }

            if (skipBlanks.HasValue)
            {
                options.Add("skip_blanks", skipBlanks);
            }

            if (noStrip.HasValue)
            {
                options.Add("no_strip", noStrip);
            }

            if (id != null)
            {
                options.Add(nameof(id), id);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("dzsave", options, filename);
        }

        /// <summary>
        /// Save image to dz buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.DzsaveBuffer(basename: string, layout: string, suffix: string, overlap: int, tileSize: int, centre: bool, depth: string, angle: string, container: string, properties: bool, compression: int, regionShrink: string, skipBlanks: int, noStrip: bool, id: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="basename">Base name to save to.</param>
        /// <param name="layout">Directory layout.</param>
        /// <param name="suffix">Filename suffix for tiles.</param>
        /// <param name="overlap">Tile overlap in pixels.</param>
        /// <param name="tileSize">Tile size in pixels.</param>
        /// <param name="centre">Center image in tile.</param>
        /// <param name="depth">Pyramid depth.</param>
        /// <param name="angle">Rotate image during save.</param>
        /// <param name="container">Pyramid container type.</param>
        /// <param name="properties">Write a properties file to the output directory.</param>
        /// <param name="compression">ZIP deflate compression level.</param>
        /// <param name="regionShrink">Method to shrink regions.</param>
        /// <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
        /// <param name="noStrip">Don't strip tile metadata.</param>
        /// <param name="id">Resource ID.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] DzsaveBuffer(string basename = null, string layout = null, string suffix = null, int? overlap = null, int? tileSize = null, bool? centre = null, string depth = null, string angle = null, string container = null, bool? properties = null, int? compression = null, string regionShrink = null, int? skipBlanks = null, bool? noStrip = null, string id = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (basename != null)
            {
                options.Add(nameof(basename), basename);
            }

            if (layout != null)
            {
                options.Add(nameof(layout), layout);
            }

            if (suffix != null)
            {
                options.Add(nameof(suffix), suffix);
            }

            if (overlap.HasValue)
            {
                options.Add(nameof(overlap), overlap);
            }

            if (tileSize.HasValue)
            {
                options.Add("tile_size", tileSize);
            }

            if (centre.HasValue)
            {
                options.Add(nameof(centre), centre);
            }

            if (depth != null)
            {
                options.Add(nameof(depth), depth);
            }

            if (angle != null)
            {
                options.Add(nameof(angle), angle);
            }

            if (container != null)
            {
                options.Add(nameof(container), container);
            }

            if (properties.HasValue)
            {
                options.Add(nameof(properties), properties);
            }

            if (compression.HasValue)
            {
                options.Add(nameof(compression), compression);
            }

            if (regionShrink != null)
            {
                options.Add("region_shrink", regionShrink);
            }

            if (skipBlanks.HasValue)
            {
                options.Add("skip_blanks", skipBlanks);
            }

            if (noStrip.HasValue)
            {
                options.Add("no_strip", noStrip);
            }

            if (id != null)
            {
                options.Add(nameof(id), id);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("dzsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Embed an image in a larger image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Embed(x, y, width, height, extend: string, background: double[]);
        /// </code>
        /// </example>
        /// <param name="x">Left edge of input in output.</param>
        /// <param name="y">Top edge of input in output.</param>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="extend">How to generate the extra pixels.</param>
        /// <param name="background">Color for background pixels.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Embed(int x, int y, int width, int height, string extend = null, double[] background = null)
        {
            var options = new VOption();

            if (extend != null)
            {
                options.Add(nameof(extend), extend);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            return this.Call("embed", options, x, y, width, height) as Image;
        }

        /// <summary>
        /// Extract an area from an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = input.ExtractArea(left, top, width, height);
        /// </code>
        /// </example>
        /// <param name="left">Left edge of extract area.</param>
        /// <param name="top">Top edge of extract area.</param>
        /// <param name="width">Width of extract area.</param>
        /// <param name="height">Height of extract area.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image ExtractArea(int left, int top, int width, int height)
        {
            return this.Call("extract_area", left, top, width, height) as Image;
        }

        /// <summary>
        /// Extract band from an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.ExtractBand(band, n: int);
        /// </code>
        /// </example>
        /// <param name="band">Band to extract.</param>
        /// <param name="n">Number of bands to extract.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image ExtractBand(int band, int? n = null)
        {
            var options = new VOption();

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            return this.Call("extract_band", options, band) as Image;
        }

        /// <summary>
        /// Make an image showing the eye's spatial response.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Eye(width, height, uchar: bool, factor: double);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="factor">Maximum spatial frequency.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Eye(int width, int height, bool? uchar = null, double? factor = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (factor.HasValue)
            {
                options.Add(nameof(factor), factor);
            }

            return Operation.Call("eye", options, width, height) as Image;
        }

        /// <summary>
        /// False-color an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Falsecolour();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Falsecolour()
        {
            return this.Call("falsecolour") as Image;
        }

        /// <summary>
        /// Fast correlation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Fastcor(@ref);
        /// </code>
        /// </example>
        /// <param name="ref">Input reference image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Fastcor(Image @ref)
        {
            return this.Call("fastcor", @ref) as Image;
        }

        /// <summary>
        /// Fill image zeros with nearest non-zero pixel.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.FillNearest();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image FillNearest()
        {
            return this.Call("fill_nearest") as Image;
        }

        /// <summary>
        /// Fill image zeros with nearest non-zero pixel.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.FillNearest(out var distance);
        /// </code>
        /// </example>
        /// <param name="distance">Distance to nearest non-zero pixel.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image FillNearest(out Image distance)
        {
            var optionalOutput = new VOption
            {
                {"distance", true}
            };

            var results = this.Call("fill_nearest", optionalOutput) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            distance = opts?["distance"] as Image;

            return finalResult;
        }

        /// <summary>
        /// Search an image for non-edge areas.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// var output = in.FindTrim(threshold: double, background: double[]);
        /// </code>
        /// </example>
        /// <param name="threshold">Object threshold.</param>
        /// <param name="background">Color for background pixels.</param>
        /// <returns>An array of objects.</returns>
        public object[] FindTrim(double? threshold = null, double[] background = null)
        {
            var options = new VOption();

            if (threshold.HasValue)
            {
                options.Add(nameof(threshold), threshold);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            return this.Call("find_trim", options) as object[];
        }

        /// <summary>
        /// Load a FITS image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Fitsload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Fitsload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("fitsload", options, filename) as Image;
        }

        /// <summary>
        /// Load a FITS image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Fitsload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Fitsload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("fitsload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Save image to fits file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Fitssave(filename, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Fitssave(string filename, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("fitssave", options, filename);
        }

        /// <summary>
        /// Flatten alpha out of an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Flatten(background: double[], maxAlpha: double);
        /// </code>
        /// </example>
        /// <param name="background">Background value.</param>
        /// <param name="maxAlpha">Maximum value of alpha channel.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Flatten(double[] background = null, double? maxAlpha = null)
        {
            var options = new VOption();

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (maxAlpha.HasValue)
            {
                options.Add("max_alpha", maxAlpha);
            }

            return this.Call("flatten", options) as Image;
        }

        /// <summary>
        /// Flip an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Flip(direction);
        /// </code>
        /// </example>
        /// <param name="direction">Direction to flip image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Flip(string direction)
        {
            return this.Call("flip", direction) as Image;
        }

        /// <summary>
        /// Transform float RGB to Radiance coding.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Float2rad();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Float2rad()
        {
            return this.Call("float2rad") as Image;
        }

        /// <summary>
        /// Make a fractal surface.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Fractsurf(width, height, fractalDimension);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="fractalDimension">Fractal dimension.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Fractsurf(int width, int height, double fractalDimension)
        {
            return Operation.Call("fractsurf", width, height, fractalDimension) as Image;
        }

        /// <summary>
        /// Frequency-domain filtering.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Freqmult(mask);
        /// </code>
        /// </example>
        /// <param name="mask">Input mask image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Freqmult(Image mask)
        {
            return this.Call("freqmult", mask) as Image;
        }

        /// <summary>
        /// Forward FFT.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Fwfft();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Fwfft()
        {
            return this.Call("fwfft") as Image;
        }

        /// <summary>
        /// Gamma an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Gamma(exponent: double);
        /// </code>
        /// </example>
        /// <param name="exponent">Gamma factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Gamma(double? exponent = null)
        {
            var options = new VOption();

            if (exponent.HasValue)
            {
                options.Add(nameof(exponent), exponent);
            }

            return this.Call("gamma", options) as Image;
        }

        /// <summary>
        /// Gaussian blur.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Gaussblur(sigma, minAmpl: double, precision: string);
        /// </code>
        /// </example>
        /// <param name="sigma">Sigma of Gaussian.</param>
        /// <param name="minAmpl">Minimum amplitude of Gaussian.</param>
        /// <param name="precision">Convolve with this precision.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Gaussblur(double sigma, double? minAmpl = null, string precision = null)
        {
            var options = new VOption();

            if (minAmpl.HasValue)
            {
                options.Add("min_ampl", minAmpl);
            }

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            return this.Call("gaussblur", options, sigma) as Image;
        }

        /// <summary>
        /// Make a gaussian image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Gaussmat(sigma, minAmpl, separable: bool, precision: string);
        /// </code>
        /// </example>
        /// <param name="sigma">Sigma of Gaussian.</param>
        /// <param name="minAmpl">Minimum amplitude of Gaussian.</param>
        /// <param name="separable">Generate separable Gaussian.</param>
        /// <param name="precision">Generate with this precision.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Gaussmat(double sigma, double minAmpl, bool? separable = null, string precision = null)
        {
            var options = new VOption();

            if (separable.HasValue)
            {
                options.Add(nameof(separable), separable);
            }

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            return Operation.Call("gaussmat", options, sigma, minAmpl) as Image;
        }

        /// <summary>
        /// Make a gaussnoise image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Gaussnoise(width, height, sigma: double, mean: double);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="sigma">Standard deviation of pixels in generated image.</param>
        /// <param name="mean">Mean of pixels in generated image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Gaussnoise(int width, int height, double? sigma = null, double? mean = null)
        {
            var options = new VOption();

            if (sigma.HasValue)
            {
                options.Add(nameof(sigma), sigma);
            }

            if (mean.HasValue)
            {
                options.Add(nameof(mean), mean);
            }

            return Operation.Call("gaussnoise", options, width, height) as Image;
        }

        /// <summary>
        /// Read a point from an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double[] outArray = in.Getpoint(x, y);
        /// </code>
        /// </example>
        /// <param name="x">Point to read.</param>
        /// <param name="y">Point to read.</param>
        /// <returns>An array of doubles.</returns>
        public double[] Getpoint(int x, int y)
        {
            return this.Call("getpoint", x, y) as double[];
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Gifload(filename, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Gifload(string filename, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("gifload", options, filename) as Image;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Gifload(filename, out var flags, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Gifload(string filename, out int flags, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("gifload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.GifloadBuffer(buffer, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image GifloadBuffer(byte[] buffer, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("gifload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.GifloadBuffer(buffer, out var flags, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image GifloadBuffer(byte[] buffer, out int flags, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("gifload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.GifloadSource(source, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image GifloadSource(Source source, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("gifload_source", options, source) as Image;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.GifloadStream(stream, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image GifloadStream(Stream stream, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = GifloadSource(source, page, n, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.GifloadSource(source, out var flags, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image GifloadSource(Source source, out int flags, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("gifload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load GIF with giflib.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.GifloadStream(stream, out var flags, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image GifloadStream(Stream stream, out int flags, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = GifloadSource(source, out flags, page, n, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Global balance an image mosaic.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Globalbalance(gamma: double, intOutput: bool);
        /// </code>
        /// </example>
        /// <param name="gamma">Image gamma.</param>
        /// <param name="intOutput">Integer output.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Globalbalance(double? gamma = null, bool? intOutput = null)
        {
            var options = new VOption();

            if (gamma.HasValue)
            {
                options.Add(nameof(gamma), gamma);
            }

            if (intOutput.HasValue)
            {
                options.Add("int_output", intOutput);
            }

            return this.Call("globalbalance", options) as Image;
        }

        /// <summary>
        /// Place an image within a larger image with a certain gravity.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Gravity(direction, width, height, extend: string, background: double[]);
        /// </code>
        /// </example>
        /// <param name="direction">direction to place image within width/height.</param>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="extend">How to generate the extra pixels.</param>
        /// <param name="background">Color for background pixels.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Gravity(string direction, int width, int height, string extend = null, double[] background = null)
        {
            var options = new VOption();

            if (extend != null)
            {
                options.Add(nameof(extend), extend);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            return this.Call("gravity", options, direction, width, height) as Image;
        }

        /// <summary>
        /// Make a grey ramp image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Grey(width, height, uchar: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Grey(int width, int height, bool? uchar = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            return Operation.Call("grey", options, width, height) as Image;
        }

        /// <summary>
        /// Grid an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Grid(tileHeight, across, down);
        /// </code>
        /// </example>
        /// <param name="tileHeight">chop into tiles this high.</param>
        /// <param name="across">number of tiles across.</param>
        /// <param name="down">number of tiles down.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Grid(int tileHeight, int across, int down)
        {
            return this.Call("grid", tileHeight, across, down) as Image;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Heifload(filename, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Heifload(string filename, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (thumbnail.HasValue)
            {
                options.Add(nameof(thumbnail), thumbnail);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("heifload", options, filename) as Image;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Heifload(filename, out var flags, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Heifload(string filename, out int flags, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (thumbnail.HasValue)
            {
                options.Add(nameof(thumbnail), thumbnail);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("heifload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.HeifloadBuffer(buffer, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image HeifloadBuffer(byte[] buffer, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (thumbnail.HasValue)
            {
                options.Add(nameof(thumbnail), thumbnail);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("heifload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.HeifloadBuffer(buffer, out var flags, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image HeifloadBuffer(byte[] buffer, out int flags, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (thumbnail.HasValue)
            {
                options.Add(nameof(thumbnail), thumbnail);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("heifload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.HeifloadSource(source, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image HeifloadSource(Source source, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (thumbnail.HasValue)
            {
                options.Add(nameof(thumbnail), thumbnail);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("heifload_source", options, source) as Image;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.HeifloadStream(stream, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image HeifloadStream(Stream stream, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = HeifloadSource(source, page, n, thumbnail, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.HeifloadSource(source, out var flags, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image HeifloadSource(Source source, out int flags, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (thumbnail.HasValue)
            {
                options.Add(nameof(thumbnail), thumbnail);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("heifload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load a HEIF image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.HeifloadStream(stream, out var flags, page: int, n: int, thumbnail: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="thumbnail">Fetch thumbnail image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image HeifloadStream(Stream stream, out int flags, int? page = null, int? n = null, bool? thumbnail = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = HeifloadSource(source, out flags, page, n, thumbnail, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image in HEIF format.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Heifsave(filename, q: int, lossless: bool, compression: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">Enable lossless compression.</param>
        /// <param name="compression">Compression format.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Heifsave(string filename, int? q = null, bool? lossless = null, string compression = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (compression != null)
            {
                options.Add(nameof(compression), compression);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("heifsave", options, filename);
        }

        /// <summary>
        /// Save image in HEIF format.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.HeifsaveBuffer(q: int, lossless: bool, compression: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">Enable lossless compression.</param>
        /// <param name="compression">Compression format.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] HeifsaveBuffer(int? q = null, bool? lossless = null, string compression = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (compression != null)
            {
                options.Add(nameof(compression), compression);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("heifsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Save image in HEIF format.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.HeifsaveTarget(target, q: int, lossless: bool, compression: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">Enable lossless compression.</param>
        /// <param name="compression">Compression format.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void HeifsaveTarget(Target target, int? q = null, bool? lossless = null, string compression = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (compression != null)
            {
                options.Add(nameof(compression), compression);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("heifsave_target", options, target);
        }

        /// <summary>
        /// Save image in HEIF format.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.HeifsaveStream(stream, q: int, lossless: bool, compression: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">Enable lossless compression.</param>
        /// <param name="compression">Compression format.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void HeifsaveStream(Stream stream, int? q = null, bool? lossless = null, string compression = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                HeifsaveTarget(target, q, lossless, compression, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Form cumulative histogram.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistCum();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistCum()
        {
            return this.Call("hist_cum") as Image;
        }

        /// <summary>
        /// Estimate image entropy.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.HistEntropy();
        /// </code>
        /// </example>
        /// <returns>A double.</returns>
        public double HistEntropy()
        {
            return this.Call("hist_entropy") is double result ? result : 0d;
        }

        /// <summary>
        /// Histogram equalisation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistEqual(band: int);
        /// </code>
        /// </example>
        /// <param name="band">Equalise with this band.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistEqual(int? band = null)
        {
            var options = new VOption();

            if (band.HasValue)
            {
                options.Add(nameof(band), band);
            }

            return this.Call("hist_equal", options) as Image;
        }

        /// <summary>
        /// Find image histogram.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistFind(band: int);
        /// </code>
        /// </example>
        /// <param name="band">Find histogram of band.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistFind(int? band = null)
        {
            var options = new VOption();

            if (band.HasValue)
            {
                options.Add(nameof(band), band);
            }

            return this.Call("hist_find", options) as Image;
        }

        /// <summary>
        /// Find indexed image histogram.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistFindIndexed(index, combine: string);
        /// </code>
        /// </example>
        /// <param name="index">Index image.</param>
        /// <param name="combine">Combine bins like this.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistFindIndexed(Image index, string combine = null)
        {
            var options = new VOption();

            if (combine != null)
            {
                options.Add(nameof(combine), combine);
            }

            return this.Call("hist_find_indexed", options, index) as Image;
        }

        /// <summary>
        /// Find n-dimensional image histogram.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistFindNdim(bins: int);
        /// </code>
        /// </example>
        /// <param name="bins">Number of bins in each dimension.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistFindNdim(int? bins = null)
        {
            var options = new VOption();

            if (bins.HasValue)
            {
                options.Add(nameof(bins), bins);
            }

            return this.Call("hist_find_ndim", options) as Image;
        }

        /// <summary>
        /// Test for monotonicity.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// bool monotonic = in.HistIsmonotonic();
        /// </code>
        /// </example>
        /// <returns>A bool.</returns>
        public bool HistIsmonotonic()
        {
            return this.Call("hist_ismonotonic") is bool result && result;
        }

        /// <summary>
        /// Local histogram equalisation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistLocal(width, height, maxSlope: int);
        /// </code>
        /// </example>
        /// <param name="width">Window width in pixels.</param>
        /// <param name="height">Window height in pixels.</param>
        /// <param name="maxSlope">Maximum slope (CLAHE).</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistLocal(int width, int height, int? maxSlope = null)
        {
            var options = new VOption();

            if (maxSlope.HasValue)
            {
                options.Add("max_slope", maxSlope);
            }

            return this.Call("hist_local", options, width, height) as Image;
        }

        /// <summary>
        /// Match two histograms.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistMatch(@ref);
        /// </code>
        /// </example>
        /// <param name="ref">Reference histogram.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistMatch(Image @ref)
        {
            return this.Call("hist_match", @ref) as Image;
        }

        /// <summary>
        /// Normalise histogram.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistNorm();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistNorm()
        {
            return this.Call("hist_norm") as Image;
        }

        /// <summary>
        /// Plot histogram.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HistPlot();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HistPlot()
        {
            return this.Call("hist_plot") as Image;
        }

        /// <summary>
        /// Find hough circle transform.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HoughCircle(scale: int, minRadius: int, maxRadius: int);
        /// </code>
        /// </example>
        /// <param name="scale">Scale down dimensions by this factor.</param>
        /// <param name="minRadius">Smallest radius to search for.</param>
        /// <param name="maxRadius">Largest radius to search for.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HoughCircle(int? scale = null, int? minRadius = null, int? maxRadius = null)
        {
            var options = new VOption();

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (minRadius.HasValue)
            {
                options.Add("min_radius", minRadius);
            }

            if (maxRadius.HasValue)
            {
                options.Add("max_radius", maxRadius);
            }

            return this.Call("hough_circle", options) as Image;
        }

        /// <summary>
        /// Find hough line transform.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HoughLine(width: int, height: int);
        /// </code>
        /// </example>
        /// <param name="width">horizontal size of parameter space.</param>
        /// <param name="height">Vertical size of parameter space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HoughLine(int? width = null, int? height = null)
        {
            var options = new VOption();

            if (width.HasValue)
            {
                options.Add(nameof(width), width);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            return this.Call("hough_line", options) as Image;
        }

        /// <summary>
        /// Transform HSV to sRGB.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.HSV2sRGB();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image HSV2sRGB()
        {
            return this.Call("HSV2sRGB") as Image;
        }

        /// <summary>
        /// Output to device with ICC profile.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.IccExport(pcs: string, intent: string, outputProfile: string, depth: int);
        /// </code>
        /// </example>
        /// <param name="pcs">Set Profile Connection Space.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <param name="outputProfile">Filename to load output profile from.</param>
        /// <param name="depth">Output device space depth in bits.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image IccExport(string pcs = null, string intent = null, string outputProfile = null, int? depth = null)
        {
            var options = new VOption();

            if (pcs != null)
            {
                options.Add(nameof(pcs), pcs);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            if (outputProfile != null)
            {
                options.Add("output_profile", outputProfile);
            }

            if (depth.HasValue)
            {
                options.Add(nameof(depth), depth);
            }

            return this.Call("icc_export", options) as Image;
        }

        /// <summary>
        /// Import from device with ICC profile.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.IccImport(pcs: string, intent: string, embedded: bool, inputProfile: string);
        /// </code>
        /// </example>
        /// <param name="pcs">Set Profile Connection Space.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <param name="embedded">Use embedded input profile, if available.</param>
        /// <param name="inputProfile">Filename to load input profile from.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image IccImport(string pcs = null, string intent = null, bool? embedded = null, string inputProfile = null)
        {
            var options = new VOption();

            if (pcs != null)
            {
                options.Add(nameof(pcs), pcs);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            if (embedded.HasValue)
            {
                options.Add(nameof(embedded), embedded);
            }

            if (inputProfile != null)
            {
                options.Add("input_profile", inputProfile);
            }

            return this.Call("icc_import", options) as Image;
        }

        /// <summary>
        /// Transform between devices with ICC profiles.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.IccTransform(outputProfile, pcs: string, intent: string, embedded: bool, inputProfile: string, depth: int);
        /// </code>
        /// </example>
        /// <param name="outputProfile">Filename to load output profile from.</param>
        /// <param name="pcs">Set Profile Connection Space.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <param name="embedded">Use embedded input profile, if available.</param>
        /// <param name="inputProfile">Filename to load input profile from.</param>
        /// <param name="depth">Output device space depth in bits.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image IccTransform(string outputProfile, string pcs = null, string intent = null, bool? embedded = null, string inputProfile = null, int? depth = null)
        {
            var options = new VOption();

            if (pcs != null)
            {
                options.Add(nameof(pcs), pcs);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            if (embedded.HasValue)
            {
                options.Add(nameof(embedded), embedded);
            }

            if (inputProfile != null)
            {
                options.Add("input_profile", inputProfile);
            }

            if (depth.HasValue)
            {
                options.Add(nameof(depth), depth);
            }

            return this.Call("icc_transform", options, outputProfile) as Image;
        }

        /// <summary>
        /// Make a 1D image where pixel values are indexes.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Identity(bands: int, @ushort: bool, size: int);
        /// </code>
        /// </example>
        /// <param name="bands">Number of bands in LUT.</param>
        /// <param name="ushort">Create a 16-bit LUT.</param>
        /// <param name="size">Size of 16-bit LUT.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Identity(int? bands = null, bool? @ushort = null, int? size = null)
        {
            var options = new VOption();

            if (bands.HasValue)
            {
                options.Add(nameof(bands), bands);
            }

            if (@ushort.HasValue)
            {
                options.Add("ushort", @ushort);
            }

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            return Operation.Call("identity", options) as Image;
        }

        /// <summary>
        /// Insert image @sub into @main at @x, @y.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = main.Insert(sub, x, y, expand: bool, background: double[]);
        /// </code>
        /// </example>
        /// <param name="sub">Sub-image to insert into main image.</param>
        /// <param name="x">Left edge of sub in main.</param>
        /// <param name="y">Top edge of sub in main.</param>
        /// <param name="expand">Expand output to hold all of both inputs.</param>
        /// <param name="background">Color for new pixels.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Insert(Image sub, int x, int y, bool? expand = null, double[] background = null)
        {
            var options = new VOption();

            if (expand.HasValue)
            {
                options.Add(nameof(expand), expand);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            return this.Call("insert", options, sub, x, y) as Image;
        }

        /// <summary>
        /// Invert an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Invert();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Invert()
        {
            return this.Call("invert") as Image;
        }

        /// <summary>
        /// Build an inverted look-up table.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Invertlut(size: int);
        /// </code>
        /// </example>
        /// <param name="size">LUT size to generate.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Invertlut(int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            return this.Call("invertlut", options) as Image;
        }

        /// <summary>
        /// Inverse FFT.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Invfft(real: bool);
        /// </code>
        /// </example>
        /// <param name="real">Output only the real part of the transform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Invfft(bool? real = null)
        {
            var options = new VOption();

            if (real.HasValue)
            {
                options.Add(nameof(real), real);
            }

            return this.Call("invfft", options) as Image;
        }

        /// <summary>
        /// Join a pair of images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in1.Join(in2, direction, expand: bool, shim: int, background: double[], align: string);
        /// </code>
        /// </example>
        /// <param name="in2">Second input image.</param>
        /// <param name="direction">Join left-right or up-down.</param>
        /// <param name="expand">Expand output to hold all of both inputs.</param>
        /// <param name="shim">Pixels between images.</param>
        /// <param name="background">Colour for new pixels.</param>
        /// <param name="align">Align on the low, centre or high coordinate edge.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Join(Image in2, string direction, bool? expand = null, int? shim = null, double[] background = null, string align = null)
        {
            var options = new VOption();

            if (expand.HasValue)
            {
                options.Add(nameof(expand), expand);
            }

            if (shim.HasValue)
            {
                options.Add(nameof(shim), shim);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (align != null)
            {
                options.Add(nameof(align), align);
            }

            return this.Call("join", options, in2, direction) as Image;
        }

        /// <summary>
        /// Load jpeg from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Jpegload(filename, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Jpegload(string filename, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (shrink.HasValue)
            {
                options.Add(nameof(shrink), shrink);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("jpegload", options, filename) as Image;
        }

        /// <summary>
        /// Load jpeg from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Jpegload(filename, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Jpegload(string filename, out int flags, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (shrink.HasValue)
            {
                options.Add(nameof(shrink), shrink);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("jpegload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load jpeg from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.JpegloadBuffer(buffer, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image JpegloadBuffer(byte[] buffer, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (shrink.HasValue)
            {
                options.Add(nameof(shrink), shrink);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("jpegload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load jpeg from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.JpegloadBuffer(buffer, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image JpegloadBuffer(byte[] buffer, out int flags, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (shrink.HasValue)
            {
                options.Add(nameof(shrink), shrink);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("jpegload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load image from jpeg source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.JpegloadSource(source, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image JpegloadSource(Source source, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (shrink.HasValue)
            {
                options.Add(nameof(shrink), shrink);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("jpegload_source", options, source) as Image;
        }

        /// <summary>
        /// Load image from jpeg stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.JpegloadStream(stream, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image JpegloadStream(Stream stream, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = JpegloadSource(source, shrink, autorotate, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load image from jpeg source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.JpegloadSource(source, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image JpegloadSource(Source source, out int flags, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (shrink.HasValue)
            {
                options.Add(nameof(shrink), shrink);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("jpegload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load image from jpeg stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.JpegloadStream(stream, out var flags, shrink: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="shrink">Shrink factor on load.</param>
        /// <param name="autorotate">Rotate image using exif orientation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image JpegloadStream(Stream stream, out int flags, int? shrink = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = JpegloadSource(source, out flags, shrink, autorotate, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to jpeg file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Jpegsave(filename, q: int, profile: string, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
        /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
        /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
        /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
        /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
        /// <param name="quantTable">Use predefined quantization table with given index.</param>
        /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Jpegsave(string filename, int? q = null, string profile = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, string subsampleMode = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (optimizeCoding.HasValue)
            {
                options.Add("optimize_coding", optimizeCoding);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (trellisQuant.HasValue)
            {
                options.Add("trellis_quant", trellisQuant);
            }

            if (overshootDeringing.HasValue)
            {
                options.Add("overshoot_deringing", overshootDeringing);
            }

            if (optimizeScans.HasValue)
            {
                options.Add("optimize_scans", optimizeScans);
            }

            if (quantTable.HasValue)
            {
                options.Add("quant_table", quantTable);
            }

            if (subsampleMode != null)
            {
                options.Add("subsample_mode", subsampleMode);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("jpegsave", options, filename);
        }

        /// <summary>
        /// Save image to jpeg buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.JpegsaveBuffer(q: int, profile: string, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="q">Q factor.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
        /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
        /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
        /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
        /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
        /// <param name="quantTable">Use predefined quantization table with given index.</param>
        /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] JpegsaveBuffer(int? q = null, string profile = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, string subsampleMode = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (optimizeCoding.HasValue)
            {
                options.Add("optimize_coding", optimizeCoding);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (trellisQuant.HasValue)
            {
                options.Add("trellis_quant", trellisQuant);
            }

            if (overshootDeringing.HasValue)
            {
                options.Add("overshoot_deringing", overshootDeringing);
            }

            if (optimizeScans.HasValue)
            {
                options.Add("optimize_scans", optimizeScans);
            }

            if (quantTable.HasValue)
            {
                options.Add("quant_table", quantTable);
            }

            if (subsampleMode != null)
            {
                options.Add("subsample_mode", subsampleMode);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("jpegsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Save image to jpeg mime.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.JpegsaveMime(q: int, profile: string, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="q">Q factor.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
        /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
        /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
        /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
        /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
        /// <param name="quantTable">Use predefined quantization table with given index.</param>
        /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void JpegsaveMime(int? q = null, string profile = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, string subsampleMode = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (optimizeCoding.HasValue)
            {
                options.Add("optimize_coding", optimizeCoding);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (trellisQuant.HasValue)
            {
                options.Add("trellis_quant", trellisQuant);
            }

            if (overshootDeringing.HasValue)
            {
                options.Add("overshoot_deringing", overshootDeringing);
            }

            if (optimizeScans.HasValue)
            {
                options.Add("optimize_scans", optimizeScans);
            }

            if (quantTable.HasValue)
            {
                options.Add("quant_table", quantTable);
            }

            if (subsampleMode != null)
            {
                options.Add("subsample_mode", subsampleMode);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("jpegsave_mime", options);
        }

        /// <summary>
        /// Save image to jpeg target.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.JpegsaveTarget(target, q: int, profile: string, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
        /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
        /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
        /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
        /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
        /// <param name="quantTable">Use predefined quantization table with given index.</param>
        /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void JpegsaveTarget(Target target, int? q = null, string profile = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, string subsampleMode = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (optimizeCoding.HasValue)
            {
                options.Add("optimize_coding", optimizeCoding);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (trellisQuant.HasValue)
            {
                options.Add("trellis_quant", trellisQuant);
            }

            if (overshootDeringing.HasValue)
            {
                options.Add("overshoot_deringing", overshootDeringing);
            }

            if (optimizeScans.HasValue)
            {
                options.Add("optimize_scans", optimizeScans);
            }

            if (quantTable.HasValue)
            {
                options.Add("quant_table", quantTable);
            }

            if (subsampleMode != null)
            {
                options.Add("subsample_mode", subsampleMode);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("jpegsave_target", options, target);
        }

        /// <summary>
        /// Save image to jpeg stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.JpegsaveStream(stream, q: int, profile: string, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
        /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
        /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
        /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
        /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
        /// <param name="quantTable">Use predefined quantization table with given index.</param>
        /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void JpegsaveStream(Stream stream, int? q = null, string profile = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, string subsampleMode = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                JpegsaveTarget(target, q, profile, optimizeCoding, interlace, trellisQuant, overshootDeringing, optimizeScans, quantTable, subsampleMode, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Transform float Lab to LabQ coding.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Lab2LabQ();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Lab2LabQ()
        {
            return this.Call("Lab2LabQ") as Image;
        }

        /// <summary>
        /// Transform float Lab to signed short.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Lab2LabS();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Lab2LabS()
        {
            return this.Call("Lab2LabS") as Image;
        }

        /// <summary>
        /// Transform Lab to LCh.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Lab2LCh();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Lab2LCh()
        {
            return this.Call("Lab2LCh") as Image;
        }

        /// <summary>
        /// Transform CIELAB to XYZ.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Lab2XYZ(temp: double[]);
        /// </code>
        /// </example>
        /// <param name="temp">Color temperature.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Lab2XYZ(double[] temp = null)
        {
            var options = new VOption();

            if (temp != null && temp.Length > 0)
            {
                options.Add(nameof(temp), temp);
            }

            return this.Call("Lab2XYZ", options) as Image;
        }

        /// <summary>
        /// Label regions in an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image mask = in.Labelregions();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Labelregions()
        {
            return this.Call("labelregions") as Image;
        }

        /// <summary>
        /// Label regions in an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image mask = in.Labelregions(out var segments);
        /// </code>
        /// </example>
        /// <param name="segments">Number of discrete contigious regions.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Labelregions(out int segments)
        {
            var optionalOutput = new VOption
            {
                {"segments", true}
            };

            var results = this.Call("labelregions", optionalOutput) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            segments = opts?["segments"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Unpack a LabQ image to float Lab.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LabQ2Lab();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LabQ2Lab()
        {
            return this.Call("LabQ2Lab") as Image;
        }

        /// <summary>
        /// Unpack a LabQ image to short Lab.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LabQ2LabS();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LabQ2LabS()
        {
            return this.Call("LabQ2LabS") as Image;
        }

        /// <summary>
        /// Convert a LabQ image to sRGB.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LabQ2sRGB();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LabQ2sRGB()
        {
            return this.Call("LabQ2sRGB") as Image;
        }

        /// <summary>
        /// Transform signed short Lab to float.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LabS2Lab();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LabS2Lab()
        {
            return this.Call("LabS2Lab") as Image;
        }

        /// <summary>
        /// Transform short Lab to LabQ coding.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LabS2LabQ();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LabS2LabQ()
        {
            return this.Call("LabS2LabQ") as Image;
        }

        /// <summary>
        /// Transform LCh to CMC.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LCh2CMC();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LCh2CMC()
        {
            return this.Call("LCh2CMC") as Image;
        }

        /// <summary>
        /// Transform LCh to Lab.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.LCh2Lab();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image LCh2Lab()
        {
            return this.Call("LCh2Lab") as Image;
        }

        /// <summary>
        /// Calculate (a * in + b).
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Linear(a, b, uchar: bool);
        /// </code>
        /// </example>
        /// <param name="a">Multiply by this.</param>
        /// <param name="b">Add this.</param>
        /// <param name="uchar">Output should be uchar.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Linear(double[] a, double[] b, bool? uchar = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            return this.Call("linear", options, a, b) as Image;
        }

        /// <summary>
        /// Cache an image as a set of lines.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Linecache(tileHeight: int, access: string, threaded: bool, persistent: bool);
        /// </code>
        /// </example>
        /// <param name="tileHeight">Tile height in pixels.</param>
        /// <param name="access">Expected access pattern.</param>
        /// <param name="threaded">Allow threaded access.</param>
        /// <param name="persistent">Keep cache between evaluations.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Linecache(int? tileHeight = null, string access = null, bool? threaded = null, bool? persistent = null)
        {
            var options = new VOption();

            if (tileHeight.HasValue)
            {
                options.Add("tile_height", tileHeight);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (threaded.HasValue)
            {
                options.Add(nameof(threaded), threaded);
            }

            if (persistent.HasValue)
            {
                options.Add(nameof(persistent), persistent);
            }

            return this.Call("linecache", options) as Image;
        }

        /// <summary>
        /// Make a laplacian of gaussian image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Logmat(sigma, minAmpl, separable: bool, precision: string);
        /// </code>
        /// </example>
        /// <param name="sigma">Radius of Logmatian.</param>
        /// <param name="minAmpl">Minimum amplitude of Logmatian.</param>
        /// <param name="separable">Generate separable Logmatian.</param>
        /// <param name="precision">Generate with this precision.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Logmat(double sigma, double minAmpl, bool? separable = null, string precision = null)
        {
            var options = new VOption();

            if (separable.HasValue)
            {
                options.Add(nameof(separable), separable);
            }

            if (precision != null)
            {
                options.Add(nameof(precision), precision);
            }

            return Operation.Call("logmat", options, sigma, minAmpl) as Image;
        }

        /// <summary>
        /// Load file with ImageMagick.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Magickload(filename, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Magickload(string filename, string density = null, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (density != null)
            {
                options.Add(nameof(density), density);
            }

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("magickload", options, filename) as Image;
        }

        /// <summary>
        /// Load file with ImageMagick.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Magickload(filename, out var flags, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Magickload(string filename, out int flags, string density = null, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (density != null)
            {
                options.Add(nameof(density), density);
            }

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("magickload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load buffer with ImageMagick.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MagickloadBuffer(buffer, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MagickloadBuffer(byte[] buffer, string density = null, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (density != null)
            {
                options.Add(nameof(density), density);
            }

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("magickload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load buffer with ImageMagick.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MagickloadBuffer(buffer, out var flags, density: string, page: int, n: int, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MagickloadBuffer(byte[] buffer, out int flags, string density = null, int? page = null, int? n = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (density != null)
            {
                options.Add(nameof(density), density);
            }

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("magickload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Save file with ImageMagick.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Magicksave(filename, format: string, quality: int, optimizeGifFrames: bool, optimizeGifTransparency: bool, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="format">Format to save in.</param>
        /// <param name="quality">Quality to use.</param>
        /// <param name="optimizeGifFrames">Apply GIF frames optimization.</param>
        /// <param name="optimizeGifTransparency">Apply GIF transparency optimization.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Magicksave(string filename, string format = null, int? quality = null, bool? optimizeGifFrames = null, bool? optimizeGifTransparency = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (format != null)
            {
                options.Add(nameof(format), format);
            }

            if (quality.HasValue)
            {
                options.Add(nameof(quality), quality);
            }

            if (optimizeGifFrames.HasValue)
            {
                options.Add("optimize_gif_frames", optimizeGifFrames);
            }

            if (optimizeGifTransparency.HasValue)
            {
                options.Add("optimize_gif_transparency", optimizeGifTransparency);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("magicksave", options, filename);
        }

        /// <summary>
        /// Save image to magick buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.MagicksaveBuffer(format: string, quality: int, optimizeGifFrames: bool, optimizeGifTransparency: bool, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="format">Format to save in.</param>
        /// <param name="quality">Quality to use.</param>
        /// <param name="optimizeGifFrames">Apply GIF frames optimization.</param>
        /// <param name="optimizeGifTransparency">Apply GIF transparency optimization.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] MagicksaveBuffer(string format = null, int? quality = null, bool? optimizeGifFrames = null, bool? optimizeGifTransparency = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (format != null)
            {
                options.Add(nameof(format), format);
            }

            if (quality.HasValue)
            {
                options.Add(nameof(quality), quality);
            }

            if (optimizeGifFrames.HasValue)
            {
                options.Add("optimize_gif_frames", optimizeGifFrames);
            }

            if (optimizeGifTransparency.HasValue)
            {
                options.Add("optimize_gif_transparency", optimizeGifTransparency);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("magicksave_buffer", options) as byte[];
        }

        /// <summary>
        /// Resample with a map image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Mapim(index, interpolate: GObject);
        /// </code>
        /// </example>
        /// <param name="index">Index pixels with this.</param>
        /// <param name="interpolate">Interpolate pixels with this.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mapim(Image index, GObject interpolate = null)
        {
            var options = new VOption();

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            return this.Call("mapim", options, index) as Image;
        }

        /// <summary>
        /// Map an image though a lut.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Maplut(lut, band: int);
        /// </code>
        /// </example>
        /// <param name="lut">Look-up table image.</param>
        /// <param name="band">apply one-band lut to this band of in.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Maplut(Image lut, int? band = null)
        {
            var options = new VOption();

            if (band.HasValue)
            {
                options.Add(nameof(band), band);
            }

            return this.Call("maplut", options, lut) as Image;
        }

        /// <summary>
        /// Make a butterworth filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskButterworth(width, height, order, frequencyCutoff, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="order">Filter order.</param>
        /// <param name="frequencyCutoff">Frequency cutoff.</param>
        /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskButterworth(int width, int height, double order, double frequencyCutoff, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_butterworth", options, width, height, order, frequencyCutoff, amplitudeCutoff) as Image;
        }

        /// <summary>
        /// Make a butterworth_band filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskButterworthBand(width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="order">Filter order.</param>
        /// <param name="frequencyCutoffX">Frequency cutoff x.</param>
        /// <param name="frequencyCutoffY">Frequency cutoff y.</param>
        /// <param name="radius">radius of circle.</param>
        /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskButterworthBand(int width, int height, double order, double frequencyCutoffX, double frequencyCutoffY, double radius, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_butterworth_band", options, width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff) as Image;
        }

        /// <summary>
        /// Make a butterworth ring filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskButterworthRing(width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="order">Filter order.</param>
        /// <param name="frequencyCutoff">Frequency cutoff.</param>
        /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
        /// <param name="ringwidth">Ringwidth.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskButterworthRing(int width, int height, double order, double frequencyCutoff, double amplitudeCutoff, double ringwidth, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_butterworth_ring", options, width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth) as Image;
        }

        /// <summary>
        /// Make fractal filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskFractal(width, height, fractalDimension, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="fractalDimension">Fractal dimension.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskFractal(int width, int height, double fractalDimension, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_fractal", options, width, height, fractalDimension) as Image;
        }

        /// <summary>
        /// Make a gaussian filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskGaussian(width, height, frequencyCutoff, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="frequencyCutoff">Frequency cutoff.</param>
        /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskGaussian(int width, int height, double frequencyCutoff, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_gaussian", options, width, height, frequencyCutoff, amplitudeCutoff) as Image;
        }

        /// <summary>
        /// Make a gaussian filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskGaussianBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="frequencyCutoffX">Frequency cutoff x.</param>
        /// <param name="frequencyCutoffY">Frequency cutoff y.</param>
        /// <param name="radius">radius of circle.</param>
        /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskGaussianBand(int width, int height, double frequencyCutoffX, double frequencyCutoffY, double radius, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_gaussian_band", options, width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff) as Image;
        }

        /// <summary>
        /// Make a gaussian ring filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskGaussianRing(width, height, frequencyCutoff, amplitudeCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="frequencyCutoff">Frequency cutoff.</param>
        /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
        /// <param name="ringwidth">Ringwidth.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskGaussianRing(int width, int height, double frequencyCutoff, double amplitudeCutoff, double ringwidth, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_gaussian_ring", options, width, height, frequencyCutoff, amplitudeCutoff, ringwidth) as Image;
        }

        /// <summary>
        /// Make an ideal filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskIdeal(width, height, frequencyCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="frequencyCutoff">Frequency cutoff.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskIdeal(int width, int height, double frequencyCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_ideal", options, width, height, frequencyCutoff) as Image;
        }

        /// <summary>
        /// Make an ideal band filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskIdealBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="frequencyCutoffX">Frequency cutoff x.</param>
        /// <param name="frequencyCutoffY">Frequency cutoff y.</param>
        /// <param name="radius">radius of circle.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskIdealBand(int width, int height, double frequencyCutoffX, double frequencyCutoffY, double radius, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_ideal_band", options, width, height, frequencyCutoffX, frequencyCutoffY, radius) as Image;
        }

        /// <summary>
        /// Make an ideal ring filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MaskIdealRing(width, height, frequencyCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="frequencyCutoff">Frequency cutoff.</param>
        /// <param name="ringwidth">Ringwidth.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="nodc">Remove DC component.</param>
        /// <param name="reject">Invert the sense of the filter.</param>
        /// <param name="optical">Rotate quadrants to optical space.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MaskIdealRing(int width, int height, double frequencyCutoff, double ringwidth, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (nodc.HasValue)
            {
                options.Add(nameof(nodc), nodc);
            }

            if (reject.HasValue)
            {
                options.Add(nameof(reject), reject);
            }

            if (optical.HasValue)
            {
                options.Add(nameof(optical), optical);
            }

            return Operation.Call("mask_ideal_ring", options, width, height, frequencyCutoff, ringwidth) as Image;
        }

        /// <summary>
        /// First-order match of two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Match(sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, hwindow: int, harea: int, search: bool, interpolate: GObject);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="xr1">Position of first reference tie-point.</param>
        /// <param name="yr1">Position of first reference tie-point.</param>
        /// <param name="xs1">Position of first secondary tie-point.</param>
        /// <param name="ys1">Position of first secondary tie-point.</param>
        /// <param name="xr2">Position of second reference tie-point.</param>
        /// <param name="yr2">Position of second reference tie-point.</param>
        /// <param name="xs2">Position of second secondary tie-point.</param>
        /// <param name="ys2">Position of second secondary tie-point.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="search">Search to improve tie-points.</param>
        /// <param name="interpolate">Interpolate pixels with this.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Match(Image sec, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int? hwindow = null, int? harea = null, bool? search = null, GObject interpolate = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (search.HasValue)
            {
                options.Add(nameof(search), search);
            }

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            return this.Call("match", options, sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2) as Image;
        }

        /// <summary>
        /// Apply a math operation to an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Math(math);
        /// </code>
        /// </example>
        /// <param name="math">math to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Math(string math)
        {
            return this.Call("math", math) as Image;
        }

        /// <summary>
        /// Binary math operations.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Math2(right, math2);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <param name="math2">math to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Math2(Image right, string math2)
        {
            return this.Call("math2", right, math2) as Image;
        }

        /// <summary>
        /// Binary math operations with a constant.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Math2Const(math2, c);
        /// </code>
        /// </example>
        /// <param name="math2">math to perform.</param>
        /// <param name="c">Array of constants.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Math2Const(string math2, double[] c)
        {
            return this.Call("math2_const", math2, c) as Image;
        }

        /// <summary>
        /// Load mat from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Matload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Matload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("matload", options, filename) as Image;
        }

        /// <summary>
        /// Load mat from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Matload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Matload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("matload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Invert an matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Matrixinvert();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Matrixinvert()
        {
            return this.Call("matrixinvert") as Image;
        }

        /// <summary>
        /// Load matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Matrixload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Matrixload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("matrixload", options, filename) as Image;
        }

        /// <summary>
        /// Load matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Matrixload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Matrixload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("matrixload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MatrixloadSource(source, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MatrixloadSource(Source source, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("matrixload_source", options, source) as Image;
        }

        /// <summary>
        /// Load matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MatrixloadStream(stream, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MatrixloadStream(Stream stream, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = MatrixloadSource(source, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MatrixloadSource(source, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MatrixloadSource(Source source, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("matrixload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.MatrixloadStream(stream, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image MatrixloadStream(Stream stream, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = MatrixloadSource(source, out flags, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Print matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Matrixprint(strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Matrixprint(bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("matrixprint", options);
        }

        /// <summary>
        /// Save image to matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Matrixsave(filename, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Matrixsave(string filename, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("matrixsave", options, filename);
        }

        /// <summary>
        /// Save image to matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.MatrixsaveTarget(target, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void MatrixsaveTarget(Target target, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("matrixsave_target", options, target);
        }

        /// <summary>
        /// Save image to matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.MatrixsaveStream(stream, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void MatrixsaveStream(Stream stream, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                MatrixsaveTarget(target, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Find image maximum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Max(size: int);
        /// </code>
        /// </example>
        /// <param name="size">Number of maximum values to find.</param>
        /// <returns>A double.</returns>
        public double Max(int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            return this.Call("max", options) is double result ? result : 0d;
        }

        /// <summary>
        /// Find image maximum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Max(out var x, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of maximum.</param>
        /// <param name="size">Number of maximum values to find.</param>
        /// <returns>A double.</returns>
        public double Max(out int x, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);

            var results = this.Call("max", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Find image maximum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Max(out var x, out var y, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of maximum.</param>
        /// <param name="y">Vertical position of maximum.</param>
        /// <param name="size">Number of maximum values to find.</param>
        /// <returns>A double.</returns>
        public double Max(out int x, out int y, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);

            var results = this.Call("max", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;

            return finalResult;
        }

        /// <summary>
        /// Find image maximum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Max(out var x, out var y, out var outArray, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of maximum.</param>
        /// <param name="y">Vertical position of maximum.</param>
        /// <param name="outArray">Array of output values.</param>
        /// <param name="size">Number of maximum values to find.</param>
        /// <returns>A double.</returns>
        public double Max(out int x, out int y, out double[] outArray, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);
            options.Add("out_array", true);

            var results = this.Call("max", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;
            outArray = opts?["out_array"] as double[];

            return finalResult;
        }

        /// <summary>
        /// Find image maximum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Max(out var x, out var y, out var outArray, out var xArray, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of maximum.</param>
        /// <param name="y">Vertical position of maximum.</param>
        /// <param name="outArray">Array of output values.</param>
        /// <param name="xArray">Array of horizontal positions.</param>
        /// <param name="size">Number of maximum values to find.</param>
        /// <returns>A double.</returns>
        public double Max(out int x, out int y, out double[] outArray, out int[] xArray, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);
            options.Add("out_array", true);
            options.Add("x_array", true);

            var results = this.Call("max", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;
            outArray = opts?["out_array"] as double[];
            xArray = opts?["x_array"] as int[];

            return finalResult;
        }

        /// <summary>
        /// Find image maximum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Max(out var x, out var y, out var outArray, out var xArray, out var yArray, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of maximum.</param>
        /// <param name="y">Vertical position of maximum.</param>
        /// <param name="outArray">Array of output values.</param>
        /// <param name="xArray">Array of horizontal positions.</param>
        /// <param name="yArray">Array of vertical positions.</param>
        /// <param name="size">Number of maximum values to find.</param>
        /// <returns>A double.</returns>
        public double Max(out int x, out int y, out double[] outArray, out int[] xArray, out int[] yArray, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);
            options.Add("out_array", true);
            options.Add("x_array", true);
            options.Add("y_array", true);

            var results = this.Call("max", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;
            outArray = opts?["out_array"] as double[];
            xArray = opts?["x_array"] as int[];
            yArray = opts?["y_array"] as int[];

            return finalResult;
        }

        /// <summary>
        /// Measure a set of patches on a color chart.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Measure(h, v, left: int, top: int, width: int, height: int);
        /// </code>
        /// </example>
        /// <param name="h">Number of patches across chart.</param>
        /// <param name="v">Number of patches down chart.</param>
        /// <param name="left">Left edge of extract area.</param>
        /// <param name="top">Top edge of extract area.</param>
        /// <param name="width">Width of extract area.</param>
        /// <param name="height">Height of extract area.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Measure(int h, int v, int? left = null, int? top = null, int? width = null, int? height = null)
        {
            var options = new VOption();

            if (left.HasValue)
            {
                options.Add(nameof(left), left);
            }

            if (top.HasValue)
            {
                options.Add(nameof(top), top);
            }

            if (width.HasValue)
            {
                options.Add(nameof(width), width);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            return this.Call("measure", options, h, v) as Image;
        }

        /// <summary>
        /// Merge two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Merge(sec, direction, dx, dy, mblend: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial merge.</param>
        /// <param name="dx">Horizontal displacement from sec to ref.</param>
        /// <param name="dy">Vertical displacement from sec to ref.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Merge(Image sec, string direction, int dx, int dy, int? mblend = null)
        {
            var options = new VOption();

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            return this.Call("merge", options, sec, direction, dx, dy) as Image;
        }

        /// <summary>
        /// Find image minimum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Min(size: int);
        /// </code>
        /// </example>
        /// <param name="size">Number of minimum values to find.</param>
        /// <returns>A double.</returns>
        public double Min(int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            return this.Call("min", options) is double result ? result : 0d;
        }

        /// <summary>
        /// Find image minimum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Min(out var x, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of minimum.</param>
        /// <param name="size">Number of minimum values to find.</param>
        /// <returns>A double.</returns>
        public double Min(out int x, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);

            var results = this.Call("min", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Find image minimum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Min(out var x, out var y, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of minimum.</param>
        /// <param name="y">Vertical position of minimum.</param>
        /// <param name="size">Number of minimum values to find.</param>
        /// <returns>A double.</returns>
        public double Min(out int x, out int y, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);

            var results = this.Call("min", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;

            return finalResult;
        }

        /// <summary>
        /// Find image minimum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Min(out var x, out var y, out var outArray, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of minimum.</param>
        /// <param name="y">Vertical position of minimum.</param>
        /// <param name="outArray">Array of output values.</param>
        /// <param name="size">Number of minimum values to find.</param>
        /// <returns>A double.</returns>
        public double Min(out int x, out int y, out double[] outArray, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);
            options.Add("out_array", true);

            var results = this.Call("min", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;
            outArray = opts?["out_array"] as double[];

            return finalResult;
        }

        /// <summary>
        /// Find image minimum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Min(out var x, out var y, out var outArray, out var xArray, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of minimum.</param>
        /// <param name="y">Vertical position of minimum.</param>
        /// <param name="outArray">Array of output values.</param>
        /// <param name="xArray">Array of horizontal positions.</param>
        /// <param name="size">Number of minimum values to find.</param>
        /// <returns>A double.</returns>
        public double Min(out int x, out int y, out double[] outArray, out int[] xArray, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);
            options.Add("out_array", true);
            options.Add("x_array", true);

            var results = this.Call("min", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;
            outArray = opts?["out_array"] as double[];
            xArray = opts?["x_array"] as int[];

            return finalResult;
        }

        /// <summary>
        /// Find image minimum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// double @out = in.Min(out var x, out var y, out var outArray, out var xArray, out var yArray, size: int);
        /// </code>
        /// </example>
        /// <param name="x">Horizontal position of minimum.</param>
        /// <param name="y">Vertical position of minimum.</param>
        /// <param name="outArray">Array of output values.</param>
        /// <param name="xArray">Array of horizontal positions.</param>
        /// <param name="yArray">Array of vertical positions.</param>
        /// <param name="size">Number of minimum values to find.</param>
        /// <returns>A double.</returns>
        public double Min(out int x, out int y, out double[] outArray, out int[] xArray, out int[] yArray, int? size = null)
        {
            var options = new VOption();

            if (size.HasValue)
            {
                options.Add(nameof(size), size);
            }

            options.Add("x", true);
            options.Add("y", true);
            options.Add("out_array", true);
            options.Add("x_array", true);
            options.Add("y_array", true);

            var results = this.Call("min", options) as object[];
            var finalResult = results?[0] is double result ? result : 0d;
            var opts = results?[1] as VOption;
            x = opts?["x"] is int out1 ? out1 : 0;
            y = opts?["y"] is int out2 ? out2 : 0;
            outArray = opts?["out_array"] as double[];
            xArray = opts?["x_array"] as int[];
            yArray = opts?["y_array"] as int[];

            return finalResult;
        }

        /// <summary>
        /// Morphology operation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Morph(mask, morph);
        /// </code>
        /// </example>
        /// <param name="mask">Input matrix image.</param>
        /// <param name="morph">Morphological operation to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Morph(Image mask, string morph)
        {
            return this.Call("morph", mask, morph) as Image;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            return this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as Image;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="dx0">Detected integer offset.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, out int dx0, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            options.Add("dx0", true);

            var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            dx0 = opts?["dx0"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="dx0">Detected integer offset.</param>
        /// <param name="dy0">Detected integer offset.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            options.Add("dx0", true);
            options.Add("dy0", true);

            var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            dx0 = opts?["dx0"] is int out1 ? out1 : 0;
            dy0 = opts?["dy0"] is int out2 ? out2 : 0;

            return finalResult;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="dx0">Detected integer offset.</param>
        /// <param name="dy0">Detected integer offset.</param>
        /// <param name="scale1">Detected scale.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            options.Add("dx0", true);
            options.Add("dy0", true);
            options.Add("scale1", true);

            var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            dx0 = opts?["dx0"] is int out1 ? out1 : 0;
            dy0 = opts?["dy0"] is int out2 ? out2 : 0;
            scale1 = opts?["scale1"] is double out3 ? out3 : 0d;

            return finalResult;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="dx0">Detected integer offset.</param>
        /// <param name="dy0">Detected integer offset.</param>
        /// <param name="scale1">Detected scale.</param>
        /// <param name="angle1">Detected rotation.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, out double angle1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            options.Add("dx0", true);
            options.Add("dy0", true);
            options.Add("scale1", true);
            options.Add("angle1", true);

            var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            dx0 = opts?["dx0"] is int out1 ? out1 : 0;
            dy0 = opts?["dy0"] is int out2 ? out2 : 0;
            scale1 = opts?["scale1"] is double out3 ? out3 : 0d;
            angle1 = opts?["angle1"] is double out4 ? out4 : 0d;

            return finalResult;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, out var dy1, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="dx0">Detected integer offset.</param>
        /// <param name="dy0">Detected integer offset.</param>
        /// <param name="scale1">Detected scale.</param>
        /// <param name="angle1">Detected rotation.</param>
        /// <param name="dy1">Detected first-order displacement.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, out double angle1, out double dy1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            options.Add("dx0", true);
            options.Add("dy0", true);
            options.Add("scale1", true);
            options.Add("angle1", true);
            options.Add("dy1", true);

            var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            dx0 = opts?["dx0"] is int out1 ? out1 : 0;
            dy0 = opts?["dy0"] is int out2 ? out2 : 0;
            scale1 = opts?["scale1"] is double out3 ? out3 : 0d;
            angle1 = opts?["angle1"] is double out4 ? out4 : 0d;
            dy1 = opts?["dy1"] is double out5 ? out5 : 0d;

            return finalResult;
        }

        /// <summary>
        /// Mosaic two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, out var dy1, out var dx1, hwindow: int, harea: int, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xref">Position of reference tie-point.</param>
        /// <param name="yref">Position of reference tie-point.</param>
        /// <param name="xsec">Position of secondary tie-point.</param>
        /// <param name="ysec">Position of secondary tie-point.</param>
        /// <param name="dx0">Detected integer offset.</param>
        /// <param name="dy0">Detected integer offset.</param>
        /// <param name="scale1">Detected scale.</param>
        /// <param name="angle1">Detected rotation.</param>
        /// <param name="dy1">Detected first-order displacement.</param>
        /// <param name="dx1">Detected first-order displacement.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic(Image sec, string direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, out double angle1, out double dy1, out double dx1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            options.Add("dx0", true);
            options.Add("dy0", true);
            options.Add("scale1", true);
            options.Add("angle1", true);
            options.Add("dy1", true);
            options.Add("dx1", true);

            var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            dx0 = opts?["dx0"] is int out1 ? out1 : 0;
            dy0 = opts?["dy0"] is int out2 ? out2 : 0;
            scale1 = opts?["scale1"] is double out3 ? out3 : 0d;
            angle1 = opts?["angle1"] is double out4 ? out4 : 0d;
            dy1 = opts?["dy1"] is double out5 ? out5 : 0d;
            dx1 = opts?["dx1"] is double out6 ? out6 : 0d;

            return finalResult;
        }

        /// <summary>
        /// First-order mosaic of two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = ref.Mosaic1(sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, hwindow: int, harea: int, search: bool, interpolate: GObject, mblend: int, bandno: int);
        /// </code>
        /// </example>
        /// <param name="sec">Secondary image.</param>
        /// <param name="direction">Horizontal or vertcial mosaic.</param>
        /// <param name="xr1">Position of first reference tie-point.</param>
        /// <param name="yr1">Position of first reference tie-point.</param>
        /// <param name="xs1">Position of first secondary tie-point.</param>
        /// <param name="ys1">Position of first secondary tie-point.</param>
        /// <param name="xr2">Position of second reference tie-point.</param>
        /// <param name="yr2">Position of second reference tie-point.</param>
        /// <param name="xs2">Position of second secondary tie-point.</param>
        /// <param name="ys2">Position of second secondary tie-point.</param>
        /// <param name="hwindow">Half window size.</param>
        /// <param name="harea">Half area size.</param>
        /// <param name="search">Search to improve tie-points.</param>
        /// <param name="interpolate">Interpolate pixels with this.</param>
        /// <param name="mblend">Maximum blend size.</param>
        /// <param name="bandno">Band to search for features on.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Mosaic1(Image sec, string direction, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int? hwindow = null, int? harea = null, bool? search = null, GObject interpolate = null, int? mblend = null, int? bandno = null)
        {
            var options = new VOption();

            if (hwindow.HasValue)
            {
                options.Add(nameof(hwindow), hwindow);
            }

            if (harea.HasValue)
            {
                options.Add(nameof(harea), harea);
            }

            if (search.HasValue)
            {
                options.Add(nameof(search), search);
            }

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            if (mblend.HasValue)
            {
                options.Add(nameof(mblend), mblend);
            }

            if (bandno.HasValue)
            {
                options.Add(nameof(bandno), bandno);
            }

            return this.Call("mosaic1", options, sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2) as Image;
        }

        /// <summary>
        /// Pick most-significant byte from an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Msb(band: int);
        /// </code>
        /// </example>
        /// <param name="band">Band to msb.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Msb(int? band = null)
        {
            var options = new VOption();

            if (band.HasValue)
            {
                options.Add(nameof(band), band);
            }

            return this.Call("msb", options) as Image;
        }

        /// <summary>
        /// Multiply two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Multiply(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Multiply(Image right)
        {
            return this.Call("multiply", right) as Image;
        }

        /// <summary>
        /// Load a NIFTI image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Niftiload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Niftiload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("niftiload", options, filename) as Image;
        }

        /// <summary>
        /// Load a NIFTI image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Niftiload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Niftiload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("niftiload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Save image to nifti file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Niftisave(filename, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Niftisave(string filename, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("niftisave", options, filename);
        }

        /// <summary>
        /// Load an OpenEXR image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Openexrload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Openexrload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("openexrload", options, filename) as Image;
        }

        /// <summary>
        /// Load an OpenEXR image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Openexrload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Openexrload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("openexrload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load file with OpenSlide.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Openslideload(filename, attachAssociated: bool, level: int, autocrop: bool, associated: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="attachAssociated">Attach all asssociated images.</param>
        /// <param name="level">Load this level from the file.</param>
        /// <param name="autocrop">Crop to image bounds.</param>
        /// <param name="associated">Load this associated image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Openslideload(string filename, bool? attachAssociated = null, int? level = null, bool? autocrop = null, string associated = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (attachAssociated.HasValue)
            {
                options.Add("attach_associated", attachAssociated);
            }

            if (level.HasValue)
            {
                options.Add(nameof(level), level);
            }

            if (autocrop.HasValue)
            {
                options.Add(nameof(autocrop), autocrop);
            }

            if (associated != null)
            {
                options.Add(nameof(associated), associated);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("openslideload", options, filename) as Image;
        }

        /// <summary>
        /// Load file with OpenSlide.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Openslideload(filename, out var flags, attachAssociated: bool, level: int, autocrop: bool, associated: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="attachAssociated">Attach all asssociated images.</param>
        /// <param name="level">Load this level from the file.</param>
        /// <param name="autocrop">Crop to image bounds.</param>
        /// <param name="associated">Load this associated image.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Openslideload(string filename, out int flags, bool? attachAssociated = null, int? level = null, bool? autocrop = null, string associated = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (attachAssociated.HasValue)
            {
                options.Add("attach_associated", attachAssociated);
            }

            if (level.HasValue)
            {
                options.Add(nameof(level), level);
            }

            if (autocrop.HasValue)
            {
                options.Add(nameof(autocrop), autocrop);
            }

            if (associated != null)
            {
                options.Add(nameof(associated), associated);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("openslideload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load PDF from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Pdfload(filename, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Pdfload(string filename, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("pdfload", options, filename) as Image;
        }

        /// <summary>
        /// Load PDF from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Pdfload(filename, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Pdfload(string filename, out int flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("pdfload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load PDF from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PdfloadBuffer(buffer, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PdfloadBuffer(byte[] buffer, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("pdfload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load PDF from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PdfloadBuffer(buffer, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PdfloadBuffer(byte[] buffer, out int flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("pdfload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load PDF from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PdfloadSource(source, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PdfloadSource(Source source, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("pdfload_source", options, source) as Image;
        }

        /// <summary>
        /// Load PDF from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PdfloadStream(stream, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PdfloadStream(Stream stream, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = PdfloadSource(source, page, n, dpi, scale, background, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load PDF from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PdfloadSource(source, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PdfloadSource(Source source, out int flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("pdfload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load PDF from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PdfloadStream(stream, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="background">Background value.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PdfloadStream(Stream stream, out int flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = PdfloadSource(source, out flags, page, n, dpi, scale, background, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Find threshold for percent of pixels.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// int threshold = in.Percent(percent);
        /// </code>
        /// </example>
        /// <param name="percent">Percent of pixels.</param>
        /// <returns>A int.</returns>
        public int Percent(double percent)
        {
            return this.Call("percent", percent) is int result ? result : 0;
        }

        /// <summary>
        /// Make a perlin noise image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Perlin(width, height, cellSize: int, uchar: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="cellSize">Size of Perlin cells.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Perlin(int width, int height, int? cellSize = null, bool? uchar = null)
        {
            var options = new VOption();

            if (cellSize.HasValue)
            {
                options.Add("cell_size", cellSize);
            }

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            return Operation.Call("perlin", options, width, height) as Image;
        }

        /// <summary>
        /// Calculate phase correlation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Phasecor(in2);
        /// </code>
        /// </example>
        /// <param name="in2">Second input image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Phasecor(Image in2)
        {
            return this.Call("phasecor", in2) as Image;
        }

        /// <summary>
        /// Load png from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Pngload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Pngload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("pngload", options, filename) as Image;
        }

        /// <summary>
        /// Load png from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Pngload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Pngload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("pngload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load png from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PngloadBuffer(buffer, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PngloadBuffer(byte[] buffer, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("pngload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load png from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PngloadBuffer(buffer, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PngloadBuffer(byte[] buffer, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("pngload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load png from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PngloadSource(source, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PngloadSource(Source source, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("pngload_source", options, source) as Image;
        }

        /// <summary>
        /// Load png from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PngloadStream(stream, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PngloadStream(Stream stream, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = PngloadSource(source, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load png from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PngloadSource(source, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PngloadSource(Source source, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("pngload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load png from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PngloadStream(stream, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PngloadStream(Stream stream, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = PngloadSource(source, out flags, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to png file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Pngsave(filename, compression: int, interlace: bool, profile: string, filter: int, palette: bool, q: int, dither: double, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="compression">Compression factor.</param>
        /// <param name="interlace">Interlace image.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="filter">libpng row filter flag(s).</param>
        /// <param name="palette">Quantise to 8bpp palette.</param>
        /// <param name="q">Quantisation quality.</param>
        /// <param name="dither">Amount of dithering.</param>
        /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Pngsave(string filename, int? compression = null, bool? interlace = null, string profile = null, int? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (compression.HasValue)
            {
                options.Add(nameof(compression), compression);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (filter.HasValue)
            {
                options.Add(nameof(filter), filter);
            }

            if (palette.HasValue)
            {
                options.Add(nameof(palette), palette);
            }

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (dither.HasValue)
            {
                options.Add(nameof(dither), dither);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("pngsave", options, filename);
        }

        /// <summary>
        /// Save image to png buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.PngsaveBuffer(compression: int, interlace: bool, profile: string, filter: int, palette: bool, q: int, dither: double, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="compression">Compression factor.</param>
        /// <param name="interlace">Interlace image.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="filter">libpng row filter flag(s).</param>
        /// <param name="palette">Quantise to 8bpp palette.</param>
        /// <param name="q">Quantisation quality.</param>
        /// <param name="dither">Amount of dithering.</param>
        /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] PngsaveBuffer(int? compression = null, bool? interlace = null, string profile = null, int? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (compression.HasValue)
            {
                options.Add(nameof(compression), compression);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (filter.HasValue)
            {
                options.Add(nameof(filter), filter);
            }

            if (palette.HasValue)
            {
                options.Add(nameof(palette), palette);
            }

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (dither.HasValue)
            {
                options.Add(nameof(dither), dither);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("pngsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Save image to target as PNG.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.PngsaveTarget(target, compression: int, interlace: bool, profile: string, filter: int, palette: bool, q: int, dither: double, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="compression">Compression factor.</param>
        /// <param name="interlace">Interlace image.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="filter">libpng row filter flag(s).</param>
        /// <param name="palette">Quantise to 8bpp palette.</param>
        /// <param name="q">Quantisation quality.</param>
        /// <param name="dither">Amount of dithering.</param>
        /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void PngsaveTarget(Target target, int? compression = null, bool? interlace = null, string profile = null, int? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (compression.HasValue)
            {
                options.Add(nameof(compression), compression);
            }

            if (interlace.HasValue)
            {
                options.Add(nameof(interlace), interlace);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (filter.HasValue)
            {
                options.Add(nameof(filter), filter);
            }

            if (palette.HasValue)
            {
                options.Add(nameof(palette), palette);
            }

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (dither.HasValue)
            {
                options.Add(nameof(dither), dither);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("pngsave_target", options, target);
        }

        /// <summary>
        /// Save image to stream as PNG.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.PngsaveStream(stream, compression: int, interlace: bool, profile: string, filter: int, palette: bool, q: int, dither: double, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="compression">Compression factor.</param>
        /// <param name="interlace">Interlace image.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="filter">libpng row filter flag(s).</param>
        /// <param name="palette">Quantise to 8bpp palette.</param>
        /// <param name="q">Quantisation quality.</param>
        /// <param name="dither">Amount of dithering.</param>
        /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void PngsaveStream(Stream stream, int? compression = null, bool? interlace = null, string profile = null, int? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                PngsaveTarget(target, compression, interlace, profile, filter, palette, q, dither, bitdepth, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Load ppm from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Ppmload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Ppmload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("ppmload", options, filename) as Image;
        }

        /// <summary>
        /// Load ppm from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Ppmload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Ppmload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("ppmload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load ppm base class.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PpmloadSource(source, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PpmloadSource(Source source, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("ppmload_source", options, source) as Image;
        }

        /// <summary>
        /// Load ppm base class.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PpmloadStream(stream, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PpmloadStream(Stream stream, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = PpmloadSource(source, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load ppm base class.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PpmloadSource(source, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PpmloadSource(Source source, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("ppmload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load ppm base class.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.PpmloadStream(stream, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image PpmloadStream(Stream stream, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = PpmloadSource(source, out flags, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to ppm file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Ppmsave(filename, ascii: bool, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="ascii">save as ascii.</param>
        /// <param name="bitdepth">Write as a 1 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Ppmsave(string filename, bool? ascii = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (ascii.HasValue)
            {
                options.Add(nameof(ascii), ascii);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("ppmsave", options, filename);
        }

        /// <summary>
        /// Save to ppm.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.PpmsaveTarget(target, ascii: bool, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="ascii">save as ascii.</param>
        /// <param name="bitdepth">Write as a 1 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void PpmsaveTarget(Target target, bool? ascii = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (ascii.HasValue)
            {
                options.Add(nameof(ascii), ascii);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("ppmsave_target", options, target);
        }

        /// <summary>
        /// Save to ppm.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.PpmsaveStream(stream, ascii: bool, bitdepth: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="ascii">save as ascii.</param>
        /// <param name="bitdepth">Write as a 1 bit image.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void PpmsaveStream(Stream stream, bool? ascii = null, int? bitdepth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                PpmsaveTarget(target, ascii, bitdepth, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Premultiply image alpha.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Premultiply(maxAlpha: double);
        /// </code>
        /// </example>
        /// <param name="maxAlpha">Maximum value of alpha channel.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Premultiply(double? maxAlpha = null)
        {
            var options = new VOption();

            if (maxAlpha.HasValue)
            {
                options.Add("max_alpha", maxAlpha);
            }

            return this.Call("premultiply", options) as Image;
        }

        /// <summary>
        /// Find image profiles.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// var output = in.Profile();
        /// </code>
        /// </example>
        /// <returns>An array of objects.</returns>
        public object[] Profile()
        {
            return this.Call("profile") as object[];
        }

        /// <summary>
        /// Load named ICC profile.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] profile = NetVips.Image.ProfileLoad(name);
        /// </code>
        /// </example>
        /// <param name="name">Profile name.</param>
        /// <returns>An array of bytes.</returns>
        public static byte[] ProfileLoad(string name)
        {
            return Operation.Call("profile_load", name) as byte[];
        }

        /// <summary>
        /// Find image projections.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// var output = in.Project();
        /// </code>
        /// </example>
        /// <returns>An array of objects.</returns>
        public object[] Project()
        {
            return this.Call("project") as object[];
        }

        /// <summary>
        /// Resample an image with a quadratic transform.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Quadratic(coeff, interpolate: GObject);
        /// </code>
        /// </example>
        /// <param name="coeff">Coefficient matrix.</param>
        /// <param name="interpolate">Interpolate values with this.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Quadratic(Image coeff, GObject interpolate = null)
        {
            var options = new VOption();

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            return this.Call("quadratic", options, coeff) as Image;
        }

        /// <summary>
        /// Unpack Radiance coding to float RGB.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Rad2float();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Rad2float()
        {
            return this.Call("rad2float") as Image;
        }

        /// <summary>
        /// Load a Radiance image from a file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Radload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Radload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("radload", options, filename) as Image;
        }

        /// <summary>
        /// Load a Radiance image from a file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Radload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Radload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("radload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load rad from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.RadloadBuffer(buffer, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image RadloadBuffer(byte[] buffer, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("radload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load rad from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.RadloadBuffer(buffer, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image RadloadBuffer(byte[] buffer, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("radload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load rad from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.RadloadSource(source, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image RadloadSource(Source source, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("radload_source", options, source) as Image;
        }

        /// <summary>
        /// Load rad from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.RadloadStream(stream, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image RadloadStream(Stream stream, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = RadloadSource(source, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load rad from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.RadloadSource(source, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image RadloadSource(Source source, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("radload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load rad from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.RadloadStream(stream, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image RadloadStream(Stream stream, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = RadloadSource(source, out flags, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to Radiance file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Radsave(filename, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Radsave(string filename, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("radsave", options, filename);
        }

        /// <summary>
        /// Save image to Radiance buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.RadsaveBuffer(strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] RadsaveBuffer(bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("radsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Save image to Radiance target.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.RadsaveTarget(target, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void RadsaveTarget(Target target, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("radsave_target", options, target);
        }

        /// <summary>
        /// Save image to Radiance stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.RadsaveStream(stream, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void RadsaveStream(Stream stream, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                RadsaveTarget(target, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Rank filter.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Rank(width, height, index);
        /// </code>
        /// </example>
        /// <param name="width">Window width in pixels.</param>
        /// <param name="height">Window height in pixels.</param>
        /// <param name="index">Select pixel at index.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Rank(int width, int height, int index)
        {
            return this.Call("rank", width, height, index) as Image;
        }

        /// <summary>
        /// Load raw data from a file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Rawload(filename, width, height, bands, offset: ulong, format: string, interpretation: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="bands">Number of bands in image.</param>
        /// <param name="offset">Offset in bytes from start of file.</param>
        /// <param name="format">Pixel format in image.</param>
        /// <param name="interpretation">Pixel interpretation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Rawload(string filename, int width, int height, int bands, ulong? offset = null, string format = null, string interpretation = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (offset.HasValue)
            {
                options.Add(nameof(offset), offset);
            }

            if (format != null)
            {
                options.Add(nameof(format), format);
            }

            if (interpretation != null)
            {
                options.Add(nameof(interpretation), interpretation);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("rawload", options, filename, width, height, bands) as Image;
        }

        /// <summary>
        /// Load raw data from a file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Rawload(filename, width, height, bands, out var flags, offset: ulong, format: string, interpretation: string, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="bands">Number of bands in image.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="offset">Offset in bytes from start of file.</param>
        /// <param name="format">Pixel format in image.</param>
        /// <param name="interpretation">Pixel interpretation.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Rawload(string filename, int width, int height, int bands, out int flags, ulong? offset = null, string format = null, string interpretation = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (offset.HasValue)
            {
                options.Add(nameof(offset), offset);
            }

            if (format != null)
            {
                options.Add(nameof(format), format);
            }

            if (interpretation != null)
            {
                options.Add(nameof(interpretation), interpretation);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("rawload", options, filename, width, height, bands) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Save image to raw file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Rawsave(filename, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Rawsave(string filename, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("rawsave", options, filename);
        }

        /// <summary>
        /// Write raw image to file descriptor.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.RawsaveFd(fd, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="fd">File descriptor to write to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void RawsaveFd(int fd, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("rawsave_fd", options, fd);
        }

        /// <summary>
        /// Linear recombination with matrix.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Recomb(m);
        /// </code>
        /// </example>
        /// <param name="m">matrix of coefficients.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Recomb(Image m)
        {
            return this.Call("recomb", m) as Image;
        }

        /// <summary>
        /// Reduce an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Reduce(hshrink, vshrink, kernel: string);
        /// </code>
        /// </example>
        /// <param name="hshrink">Horizontal shrink factor.</param>
        /// <param name="vshrink">Vertical shrink factor.</param>
        /// <param name="kernel">Resampling kernel.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Reduce(double hshrink, double vshrink, string kernel = null)
        {
            var options = new VOption();

            if (kernel != null)
            {
                options.Add(nameof(kernel), kernel);
            }

            return this.Call("reduce", options, hshrink, vshrink) as Image;
        }

        /// <summary>
        /// Shrink an image horizontally.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Reduceh(hshrink, kernel: string);
        /// </code>
        /// </example>
        /// <param name="hshrink">Horizontal shrink factor.</param>
        /// <param name="kernel">Resampling kernel.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Reduceh(double hshrink, string kernel = null)
        {
            var options = new VOption();

            if (kernel != null)
            {
                options.Add(nameof(kernel), kernel);
            }

            return this.Call("reduceh", options, hshrink) as Image;
        }

        /// <summary>
        /// Shrink an image vertically.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Reducev(vshrink, kernel: string);
        /// </code>
        /// </example>
        /// <param name="vshrink">Vertical shrink factor.</param>
        /// <param name="kernel">Resampling kernel.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Reducev(double vshrink, string kernel = null)
        {
            var options = new VOption();

            if (kernel != null)
            {
                options.Add(nameof(kernel), kernel);
            }

            return this.Call("reducev", options, vshrink) as Image;
        }

        /// <summary>
        /// Relational operation on two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Relational(right, relational);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <param name="relational">relational to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Relational(Image right, string relational)
        {
            return this.Call("relational", right, relational) as Image;
        }

        /// <summary>
        /// Relational operations against a constant.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.RelationalConst(relational, c);
        /// </code>
        /// </example>
        /// <param name="relational">relational to perform.</param>
        /// <param name="c">Array of constants.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image RelationalConst(string relational, double[] c)
        {
            return this.Call("relational_const", relational, c) as Image;
        }

        /// <summary>
        /// Remainder after integer division of two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Remainder(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Remainder(Image right)
        {
            return this.Call("remainder", right) as Image;
        }

        /// <summary>
        /// Remainder after integer division of an image and a constant.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.RemainderConst(c);
        /// </code>
        /// </example>
        /// <param name="c">Array of constants.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image RemainderConst(double[] c)
        {
            return this.Call("remainder_const", c) as Image;
        }

        /// <summary>
        /// Replicate an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Replicate(across, down);
        /// </code>
        /// </example>
        /// <param name="across">Repeat this many times horizontally.</param>
        /// <param name="down">Repeat this many times vertically.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Replicate(int across, int down)
        {
            return this.Call("replicate", across, down) as Image;
        }

        /// <summary>
        /// Resize an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Resize(scale, kernel: string, vscale: double);
        /// </code>
        /// </example>
        /// <param name="scale">Scale image by this factor.</param>
        /// <param name="kernel">Resampling kernel.</param>
        /// <param name="vscale">Vertical scale image by this factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Resize(double scale, string kernel = null, double? vscale = null)
        {
            var options = new VOption();

            if (kernel != null)
            {
                options.Add(nameof(kernel), kernel);
            }

            if (vscale.HasValue)
            {
                options.Add(nameof(vscale), vscale);
            }

            return this.Call("resize", options, scale) as Image;
        }

        /// <summary>
        /// Rotate an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Rot(angle);
        /// </code>
        /// </example>
        /// <param name="angle">Angle to rotate image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Rot(string angle)
        {
            return this.Call("rot", angle) as Image;
        }

        /// <summary>
        /// Rotate an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Rot45(angle: string);
        /// </code>
        /// </example>
        /// <param name="angle">Angle to rotate image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Rot45(string angle = null)
        {
            var options = new VOption();

            if (angle != null)
            {
                options.Add(nameof(angle), angle);
            }

            return this.Call("rot45", options) as Image;
        }

        /// <summary>
        /// Rotate an image by a number of degrees.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Rotate(angle, interpolate: GObject, background: double[], odx: double, ody: double, idx: double, idy: double);
        /// </code>
        /// </example>
        /// <param name="angle">Rotate anticlockwise by this many degrees.</param>
        /// <param name="interpolate">Interpolate pixels with this.</param>
        /// <param name="background">Background value.</param>
        /// <param name="odx">Horizontal output displacement.</param>
        /// <param name="ody">Vertical output displacement.</param>
        /// <param name="idx">Horizontal input displacement.</param>
        /// <param name="idy">Vertical input displacement.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Rotate(double angle, GObject interpolate = null, double[] background = null, double? odx = null, double? ody = null, double? idx = null, double? idy = null)
        {
            var options = new VOption();

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (odx.HasValue)
            {
                options.Add(nameof(odx), odx);
            }

            if (ody.HasValue)
            {
                options.Add(nameof(ody), ody);
            }

            if (idx.HasValue)
            {
                options.Add(nameof(idx), idx);
            }

            if (idy.HasValue)
            {
                options.Add(nameof(idy), idy);
            }

            return this.Call("rotate", options, angle) as Image;
        }

        /// <summary>
        /// Perform a round function on an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Round(round);
        /// </code>
        /// </example>
        /// <param name="round">rounding operation to perform.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Round(string round)
        {
            return this.Call("round", round) as Image;
        }

        /// <summary>
        /// Convert scRGB to BW.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.ScRGB2BW(depth: int);
        /// </code>
        /// </example>
        /// <param name="depth">Output device space depth in bits.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image ScRGB2BW(int? depth = null)
        {
            var options = new VOption();

            if (depth.HasValue)
            {
                options.Add(nameof(depth), depth);
            }

            return this.Call("scRGB2BW", options) as Image;
        }

        /// <summary>
        /// Convert an scRGB image to sRGB.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.ScRGB2sRGB(depth: int);
        /// </code>
        /// </example>
        /// <param name="depth">Output device space depth in bits.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image ScRGB2sRGB(int? depth = null)
        {
            var options = new VOption();

            if (depth.HasValue)
            {
                options.Add(nameof(depth), depth);
            }

            return this.Call("scRGB2sRGB", options) as Image;
        }

        /// <summary>
        /// Transform scRGB to XYZ.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.ScRGB2XYZ();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image ScRGB2XYZ()
        {
            return this.Call("scRGB2XYZ") as Image;
        }

        /// <summary>
        /// Check sequential access.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Sequential(tileHeight: int);
        /// </code>
        /// </example>
        /// <param name="tileHeight">Tile height in pixels.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Sequential(int? tileHeight = null)
        {
            var options = new VOption();

            if (tileHeight.HasValue)
            {
                options.Add("tile_height", tileHeight);
            }

            return this.Call("sequential", options) as Image;
        }

        /// <summary>
        /// Unsharp masking for print.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Sharpen(sigma: double, x1: double, y2: double, y3: double, m1: double, m2: double);
        /// </code>
        /// </example>
        /// <param name="sigma">Sigma of Gaussian.</param>
        /// <param name="x1">Flat/jaggy threshold.</param>
        /// <param name="y2">Maximum brightening.</param>
        /// <param name="y3">Maximum darkening.</param>
        /// <param name="m1">Slope for flat areas.</param>
        /// <param name="m2">Slope for jaggy areas.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Sharpen(double? sigma = null, double? x1 = null, double? y2 = null, double? y3 = null, double? m1 = null, double? m2 = null)
        {
            var options = new VOption();

            if (sigma.HasValue)
            {
                options.Add(nameof(sigma), sigma);
            }

            if (x1.HasValue)
            {
                options.Add(nameof(x1), x1);
            }

            if (y2.HasValue)
            {
                options.Add(nameof(y2), y2);
            }

            if (y3.HasValue)
            {
                options.Add(nameof(y3), y3);
            }

            if (m1.HasValue)
            {
                options.Add(nameof(m1), m1);
            }

            if (m2.HasValue)
            {
                options.Add(nameof(m2), m2);
            }

            return this.Call("sharpen", options) as Image;
        }

        /// <summary>
        /// Shrink an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Shrink(hshrink, vshrink);
        /// </code>
        /// </example>
        /// <param name="hshrink">Horizontal shrink factor.</param>
        /// <param name="vshrink">Vertical shrink factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Shrink(double hshrink, double vshrink)
        {
            return this.Call("shrink", hshrink, vshrink) as Image;
        }

        /// <summary>
        /// Shrink an image horizontally.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Shrinkh(hshrink);
        /// </code>
        /// </example>
        /// <param name="hshrink">Horizontal shrink factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Shrinkh(int hshrink)
        {
            return this.Call("shrinkh", hshrink) as Image;
        }

        /// <summary>
        /// Shrink an image vertically.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Shrinkv(vshrink);
        /// </code>
        /// </example>
        /// <param name="vshrink">Vertical shrink factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Shrinkv(int vshrink)
        {
            return this.Call("shrinkv", vshrink) as Image;
        }

        /// <summary>
        /// Unit vector of pixel.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Sign();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Sign()
        {
            return this.Call("sign") as Image;
        }

        /// <summary>
        /// Similarity transform of an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Similarity(scale: double, angle: double, interpolate: GObject, background: double[], odx: double, ody: double, idx: double, idy: double);
        /// </code>
        /// </example>
        /// <param name="scale">Scale by this factor.</param>
        /// <param name="angle">Rotate anticlockwise by this many degrees.</param>
        /// <param name="interpolate">Interpolate pixels with this.</param>
        /// <param name="background">Background value.</param>
        /// <param name="odx">Horizontal output displacement.</param>
        /// <param name="ody">Vertical output displacement.</param>
        /// <param name="idx">Horizontal input displacement.</param>
        /// <param name="idy">Vertical input displacement.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Similarity(double? scale = null, double? angle = null, GObject interpolate = null, double[] background = null, double? odx = null, double? ody = null, double? idx = null, double? idy = null)
        {
            var options = new VOption();

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (angle.HasValue)
            {
                options.Add(nameof(angle), angle);
            }

            if (interpolate != null)
            {
                options.Add(nameof(interpolate), interpolate);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (odx.HasValue)
            {
                options.Add(nameof(odx), odx);
            }

            if (ody.HasValue)
            {
                options.Add(nameof(ody), ody);
            }

            if (idx.HasValue)
            {
                options.Add(nameof(idx), idx);
            }

            if (idy.HasValue)
            {
                options.Add(nameof(idy), idy);
            }

            return this.Call("similarity", options) as Image;
        }

        /// <summary>
        /// Make a 2D sine wave.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Sines(width, height, uchar: bool, hfreq: double, vfreq: double);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <param name="hfreq">Horizontal spatial frequency.</param>
        /// <param name="vfreq">Vertical spatial frequency.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Sines(int width, int height, bool? uchar = null, double? hfreq = null, double? vfreq = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            if (hfreq.HasValue)
            {
                options.Add(nameof(hfreq), hfreq);
            }

            if (vfreq.HasValue)
            {
                options.Add(nameof(vfreq), vfreq);
            }

            return Operation.Call("sines", options, width, height) as Image;
        }

        /// <summary>
        /// Extract an area from an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = input.Smartcrop(width, height, interesting: string);
        /// </code>
        /// </example>
        /// <param name="width">Width of extract area.</param>
        /// <param name="height">Height of extract area.</param>
        /// <param name="interesting">How to measure interestingness.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Smartcrop(int width, int height, string interesting = null)
        {
            var options = new VOption();

            if (interesting != null)
            {
                options.Add(nameof(interesting), interesting);
            }

            return this.Call("smartcrop", options, width, height) as Image;
        }

        /// <summary>
        /// Sobel edge detector.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Sobel();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Sobel()
        {
            return this.Call("sobel") as Image;
        }

        /// <summary>
        /// Spatial correlation.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Spcor(@ref);
        /// </code>
        /// </example>
        /// <param name="ref">Input reference image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Spcor(Image @ref)
        {
            return this.Call("spcor", @ref) as Image;
        }

        /// <summary>
        /// Make displayable power spectrum.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Spectrum();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Spectrum()
        {
            return this.Call("spectrum") as Image;
        }

        /// <summary>
        /// Transform sRGB to HSV.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.SRGB2HSV();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image SRGB2HSV()
        {
            return this.Call("sRGB2HSV") as Image;
        }

        /// <summary>
        /// Convert an sRGB image to scRGB.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.SRGB2scRGB();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image SRGB2scRGB()
        {
            return this.Call("sRGB2scRGB") as Image;
        }

        /// <summary>
        /// Find many image stats.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Stats();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Stats()
        {
            return this.Call("stats") as Image;
        }

        /// <summary>
        /// Statistical difference.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Stdif(width, height, s0: double, b: double, m0: double, a: double);
        /// </code>
        /// </example>
        /// <param name="width">Window width in pixels.</param>
        /// <param name="height">Window height in pixels.</param>
        /// <param name="s0">New deviation.</param>
        /// <param name="b">Weight of new deviation.</param>
        /// <param name="m0">New mean.</param>
        /// <param name="a">Weight of new mean.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Stdif(int width, int height, double? s0 = null, double? b = null, double? m0 = null, double? a = null)
        {
            var options = new VOption();

            if (s0.HasValue)
            {
                options.Add(nameof(s0), s0);
            }

            if (b.HasValue)
            {
                options.Add(nameof(b), b);
            }

            if (m0.HasValue)
            {
                options.Add(nameof(m0), m0);
            }

            if (a.HasValue)
            {
                options.Add(nameof(a), a);
            }

            return this.Call("stdif", options, width, height) as Image;
        }

        /// <summary>
        /// Subsample an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = input.Subsample(xfac, yfac, point: bool);
        /// </code>
        /// </example>
        /// <param name="xfac">Horizontal subsample factor.</param>
        /// <param name="yfac">Vertical subsample factor.</param>
        /// <param name="point">Point sample.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Subsample(int xfac, int yfac, bool? point = null)
        {
            var options = new VOption();

            if (point.HasValue)
            {
                options.Add(nameof(point), point);
            }

            return this.Call("subsample", options, xfac, yfac) as Image;
        }

        /// <summary>
        /// Subtract two images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = left.Subtract(right);
        /// </code>
        /// </example>
        /// <param name="right">Right-hand image argument.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Subtract(Image right)
        {
            return this.Call("subtract", right) as Image;
        }

        /// <summary>
        /// Sum an array of images.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Sum(@in);
        /// </code>
        /// </example>
        /// <param name="in">Array of input images.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Sum(params Image[] @in)
        {
            return Operation.Call("sum", new object[] { @in }) as Image;
        }

        /// <summary>
        /// Load SVG with rsvg.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Svgload(filename, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Svgload(string filename, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (unlimited.HasValue)
            {
                options.Add(nameof(unlimited), unlimited);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("svgload", options, filename) as Image;
        }

        /// <summary>
        /// Load SVG with rsvg.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Svgload(filename, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Svgload(string filename, out int flags, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (unlimited.HasValue)
            {
                options.Add(nameof(unlimited), unlimited);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("svgload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load SVG with rsvg.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.SvgloadBuffer(buffer, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image SvgloadBuffer(byte[] buffer, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (unlimited.HasValue)
            {
                options.Add(nameof(unlimited), unlimited);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("svgload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load SVG with rsvg.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.SvgloadBuffer(buffer, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image SvgloadBuffer(byte[] buffer, out int flags, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (unlimited.HasValue)
            {
                options.Add(nameof(unlimited), unlimited);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("svgload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load svg from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.SvgloadSource(source, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image SvgloadSource(Source source, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (unlimited.HasValue)
            {
                options.Add(nameof(unlimited), unlimited);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("svgload_source", options, source) as Image;
        }

        /// <summary>
        /// Load svg from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.SvgloadStream(stream, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image SvgloadStream(Stream stream, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = SvgloadSource(source, dpi, scale, unlimited, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load svg from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.SvgloadSource(source, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image SvgloadSource(Source source, out int flags, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (unlimited.HasValue)
            {
                options.Add(nameof(unlimited), unlimited);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("svgload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load svg from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.SvgloadStream(stream, out var flags, dpi: double, scale: double, unlimited: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="dpi">Render at this DPI.</param>
        /// <param name="scale">Scale output by this factor.</param>
        /// <param name="unlimited">Allow SVG of any size.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image SvgloadStream(Stream stream, out int flags, double? dpi = null, double? scale = null, bool? unlimited = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = SvgloadSource(source, out flags, dpi, scale, unlimited, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Find the index of the first non-zero pixel in tests.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Switch(tests);
        /// </code>
        /// </example>
        /// <param name="tests">Table of images to test.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Switch(params Image[] tests)
        {
            return Operation.Call("switch", new object[] { tests }) as Image;
        }

        /// <summary>
        /// Run an external command.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// NetVips.Image.System(cmdFormat, @in: Image[], outFormat: string, inFormat: string);
        /// </code>
        /// </example>
        /// <param name="cmdFormat">Command to run.</param>
        /// <param name="in">Array of input images.</param>
        /// <param name="outFormat">Format for output filename.</param>
        /// <param name="inFormat">Format for input filename.</param>
        public static void System(string cmdFormat, Image[] @in = null, string outFormat = null, string inFormat = null)
        {
            var options = new VOption();

            if (@in != null && @in.Length > 0)
            {
                options.Add("in", @in);
            }

            if (outFormat != null)
            {
                options.Add("out_format", outFormat);
            }

            if (inFormat != null)
            {
                options.Add("in_format", inFormat);
            }

            Operation.Call("system", options, cmdFormat);
        }

        /// <summary>
        /// Run an external command.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// NetVips.Image.System(cmdFormat, out var @out, @in: Image[], outFormat: string, inFormat: string);
        /// </code>
        /// </example>
        /// <param name="cmdFormat">Command to run.</param>
        /// <param name="out">Output image.</param>
        /// <param name="in">Array of input images.</param>
        /// <param name="outFormat">Format for output filename.</param>
        /// <param name="inFormat">Format for input filename.</param>
        public static void System(string cmdFormat, out Image @out, Image[] @in = null, string outFormat = null, string inFormat = null)
        {
            var options = new VOption();

            if (@in != null && @in.Length > 0)
            {
                options.Add("in", @in);
            }

            if (outFormat != null)
            {
                options.Add("out_format", outFormat);
            }

            if (inFormat != null)
            {
                options.Add("in_format", inFormat);
            }

            options.Add("out", true);

            var results = Operation.Call("system", options, cmdFormat) as object[];

            var opts = results?[1] as VOption;
            @out = opts?["out"] as Image;
        }

        /// <summary>
        /// Run an external command.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// NetVips.Image.System(cmdFormat, out var @out, out var log, @in: Image[], outFormat: string, inFormat: string);
        /// </code>
        /// </example>
        /// <param name="cmdFormat">Command to run.</param>
        /// <param name="out">Output image.</param>
        /// <param name="log">Command log.</param>
        /// <param name="in">Array of input images.</param>
        /// <param name="outFormat">Format for output filename.</param>
        /// <param name="inFormat">Format for input filename.</param>
        public static void System(string cmdFormat, out Image @out, out string log, Image[] @in = null, string outFormat = null, string inFormat = null)
        {
            var options = new VOption();

            if (@in != null && @in.Length > 0)
            {
                options.Add("in", @in);
            }

            if (outFormat != null)
            {
                options.Add("out_format", outFormat);
            }

            if (inFormat != null)
            {
                options.Add("in_format", inFormat);
            }

            options.Add("out", true);
            options.Add("log", true);

            var results = Operation.Call("system", options, cmdFormat) as object[];

            var opts = results?[1] as VOption;
            @out = opts?["out"] as Image;
            log = opts?["log"] is string out2 ? out2 : null;
        }

        /// <summary>
        /// Make a text image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Text(text, font: string, width: int, height: int, align: string, dpi: int, justify: bool, spacing: int, fontfile: string);
        /// </code>
        /// </example>
        /// <param name="text">Text to render.</param>
        /// <param name="font">Font to render with.</param>
        /// <param name="width">Maximum image width in pixels.</param>
        /// <param name="height">Maximum image height in pixels.</param>
        /// <param name="align">Align on the low, centre or high edge.</param>
        /// <param name="dpi">DPI to render at.</param>
        /// <param name="justify">Justify lines.</param>
        /// <param name="spacing">Line spacing.</param>
        /// <param name="fontfile">Load this font file.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Text(string text, string font = null, int? width = null, int? height = null, string align = null, int? dpi = null, bool? justify = null, int? spacing = null, string fontfile = null)
        {
            var options = new VOption();

            if (font != null)
            {
                options.Add(nameof(font), font);
            }

            if (width.HasValue)
            {
                options.Add(nameof(width), width);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (align != null)
            {
                options.Add(nameof(align), align);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (justify.HasValue)
            {
                options.Add(nameof(justify), justify);
            }

            if (spacing.HasValue)
            {
                options.Add(nameof(spacing), spacing);
            }

            if (fontfile != null)
            {
                options.Add(nameof(fontfile), fontfile);
            }

            return Operation.Call("text", options, text) as Image;
        }

        /// <summary>
        /// Make a text image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Text(text, out var autofitDpi, font: string, width: int, height: int, align: string, dpi: int, justify: bool, spacing: int, fontfile: string);
        /// </code>
        /// </example>
        /// <param name="text">Text to render.</param>
        /// <param name="autofitDpi">DPI selected by autofit.</param>
        /// <param name="font">Font to render with.</param>
        /// <param name="width">Maximum image width in pixels.</param>
        /// <param name="height">Maximum image height in pixels.</param>
        /// <param name="align">Align on the low, centre or high edge.</param>
        /// <param name="dpi">DPI to render at.</param>
        /// <param name="justify">Justify lines.</param>
        /// <param name="spacing">Line spacing.</param>
        /// <param name="fontfile">Load this font file.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Text(string text, out int autofitDpi, string font = null, int? width = null, int? height = null, string align = null, int? dpi = null, bool? justify = null, int? spacing = null, string fontfile = null)
        {
            var options = new VOption();

            if (font != null)
            {
                options.Add(nameof(font), font);
            }

            if (width.HasValue)
            {
                options.Add(nameof(width), width);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (align != null)
            {
                options.Add(nameof(align), align);
            }

            if (dpi.HasValue)
            {
                options.Add(nameof(dpi), dpi);
            }

            if (justify.HasValue)
            {
                options.Add(nameof(justify), justify);
            }

            if (spacing.HasValue)
            {
                options.Add(nameof(spacing), spacing);
            }

            if (fontfile != null)
            {
                options.Add(nameof(fontfile), fontfile);
            }

            options.Add("autofit_dpi", true);

            var results = Operation.Call("text", options, text) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            autofitDpi = opts?["autofit_dpi"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Generate thumbnail from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Thumbnail(filename, width, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to read from.</param>
        /// <param name="width">Size to this width.</param>
        /// <param name="height">Size to this height.</param>
        /// <param name="size">Only upsize, only downsize, or both.</param>
        /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
        /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
        /// <param name="linear">Reduce in linear light.</param>
        /// <param name="importProfile">Fallback import profile.</param>
        /// <param name="exportProfile">Fallback export profile.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Thumbnail(string filename, int width, int? height = null, string size = null, bool? noRotate = null, string crop = null, bool? linear = null, string importProfile = null, string exportProfile = null, string intent = null)
        {
            var options = new VOption();

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (size != null)
            {
                options.Add(nameof(size), size);
            }

            if (noRotate.HasValue)
            {
                options.Add("no_rotate", noRotate);
            }

            if (crop != null)
            {
                options.Add(nameof(crop), crop);
            }

            if (linear.HasValue)
            {
                options.Add(nameof(linear), linear);
            }

            if (importProfile != null)
            {
                options.Add("import_profile", importProfile);
            }

            if (exportProfile != null)
            {
                options.Add("export_profile", exportProfile);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            return Operation.Call("thumbnail", options, filename, width) as Image;
        }

        /// <summary>
        /// Generate thumbnail from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.ThumbnailBuffer(buffer, width, optionString: string, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="width">Size to this width.</param>
        /// <param name="optionString">Options that are passed on to the underlying loader.</param>
        /// <param name="height">Size to this height.</param>
        /// <param name="size">Only upsize, only downsize, or both.</param>
        /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
        /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
        /// <param name="linear">Reduce in linear light.</param>
        /// <param name="importProfile">Fallback import profile.</param>
        /// <param name="exportProfile">Fallback export profile.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image ThumbnailBuffer(byte[] buffer, int width, string optionString = null, int? height = null, string size = null, bool? noRotate = null, string crop = null, bool? linear = null, string importProfile = null, string exportProfile = null, string intent = null)
        {
            var options = new VOption();

            if (optionString != null)
            {
                options.Add("option_string", optionString);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (size != null)
            {
                options.Add(nameof(size), size);
            }

            if (noRotate.HasValue)
            {
                options.Add("no_rotate", noRotate);
            }

            if (crop != null)
            {
                options.Add(nameof(crop), crop);
            }

            if (linear.HasValue)
            {
                options.Add(nameof(linear), linear);
            }

            if (importProfile != null)
            {
                options.Add("import_profile", importProfile);
            }

            if (exportProfile != null)
            {
                options.Add("export_profile", exportProfile);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            return Operation.Call("thumbnail_buffer", options, buffer, width) as Image;
        }

        /// <summary>
        /// Generate thumbnail from image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.ThumbnailImage(width, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
        /// </code>
        /// </example>
        /// <param name="width">Size to this width.</param>
        /// <param name="height">Size to this height.</param>
        /// <param name="size">Only upsize, only downsize, or both.</param>
        /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
        /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
        /// <param name="linear">Reduce in linear light.</param>
        /// <param name="importProfile">Fallback import profile.</param>
        /// <param name="exportProfile">Fallback export profile.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image ThumbnailImage(int width, int? height = null, string size = null, bool? noRotate = null, string crop = null, bool? linear = null, string importProfile = null, string exportProfile = null, string intent = null)
        {
            var options = new VOption();

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (size != null)
            {
                options.Add(nameof(size), size);
            }

            if (noRotate.HasValue)
            {
                options.Add("no_rotate", noRotate);
            }

            if (crop != null)
            {
                options.Add(nameof(crop), crop);
            }

            if (linear.HasValue)
            {
                options.Add(nameof(linear), linear);
            }

            if (importProfile != null)
            {
                options.Add("import_profile", importProfile);
            }

            if (exportProfile != null)
            {
                options.Add("export_profile", exportProfile);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            return this.Call("thumbnail_image", options, width) as Image;
        }

        /// <summary>
        /// Generate thumbnail from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.ThumbnailSource(source, width, optionString: string, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="width">Size to this width.</param>
        /// <param name="optionString">Options that are passed on to the underlying loader.</param>
        /// <param name="height">Size to this height.</param>
        /// <param name="size">Only upsize, only downsize, or both.</param>
        /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
        /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
        /// <param name="linear">Reduce in linear light.</param>
        /// <param name="importProfile">Fallback import profile.</param>
        /// <param name="exportProfile">Fallback export profile.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image ThumbnailSource(Source source, int width, string optionString = null, int? height = null, string size = null, bool? noRotate = null, string crop = null, bool? linear = null, string importProfile = null, string exportProfile = null, string intent = null)
        {
            var options = new VOption();

            if (optionString != null)
            {
                options.Add("option_string", optionString);
            }

            if (height.HasValue)
            {
                options.Add(nameof(height), height);
            }

            if (size != null)
            {
                options.Add(nameof(size), size);
            }

            if (noRotate.HasValue)
            {
                options.Add("no_rotate", noRotate);
            }

            if (crop != null)
            {
                options.Add(nameof(crop), crop);
            }

            if (linear.HasValue)
            {
                options.Add(nameof(linear), linear);
            }

            if (importProfile != null)
            {
                options.Add("import_profile", importProfile);
            }

            if (exportProfile != null)
            {
                options.Add("export_profile", exportProfile);
            }

            if (intent != null)
            {
                options.Add(nameof(intent), intent);
            }

            return Operation.Call("thumbnail_source", options, source, width) as Image;
        }

        /// <summary>
        /// Generate thumbnail from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.ThumbnailStream(stream, width, optionString: string, height: int, size: string, noRotate: bool, crop: string, linear: bool, importProfile: string, exportProfile: string, intent: string);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="width">Size to this width.</param>
        /// <param name="optionString">Options that are passed on to the underlying loader.</param>
        /// <param name="height">Size to this height.</param>
        /// <param name="size">Only upsize, only downsize, or both.</param>
        /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
        /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
        /// <param name="linear">Reduce in linear light.</param>
        /// <param name="importProfile">Fallback import profile.</param>
        /// <param name="exportProfile">Fallback export profile.</param>
        /// <param name="intent">Rendering intent.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image ThumbnailStream(Stream stream, int width, string optionString = null, int? height = null, string size = null, bool? noRotate = null, string crop = null, bool? linear = null, string importProfile = null, string exportProfile = null, string intent = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = ThumbnailSource(source, width, optionString, height, size, noRotate, crop, linear, importProfile, exportProfile, intent);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load tiff from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Tiffload(filename, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Tiffload(string filename, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("tiffload", options, filename) as Image;
        }

        /// <summary>
        /// Load tiff from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Tiffload(filename, out var flags, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Tiffload(string filename, out int flags, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("tiffload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load tiff from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.TiffloadBuffer(buffer, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image TiffloadBuffer(byte[] buffer, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("tiffload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load tiff from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.TiffloadBuffer(buffer, out var flags, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image TiffloadBuffer(byte[] buffer, out int flags, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("tiffload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load tiff from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.TiffloadSource(source, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image TiffloadSource(Source source, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("tiffload_source", options, source) as Image;
        }

        /// <summary>
        /// Load tiff from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.TiffloadStream(stream, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image TiffloadStream(Stream stream, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = TiffloadSource(source, page, subifd, n, autorotate, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load tiff from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.TiffloadSource(source, out var flags, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image TiffloadSource(Source source, out int flags, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (autorotate.HasValue)
            {
                options.Add(nameof(autorotate), autorotate);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("tiffload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load tiff from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.TiffloadStream(stream, out var flags, page: int, subifd: int, n: int, autorotate: bool, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the image.</param>
        /// <param name="subifd">Select subifd index.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="autorotate">Rotate image using orientation tag.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image TiffloadStream(Stream stream, out int flags, int? page = null, int? subifd = null, int? n = null, bool? autorotate = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = TiffloadSource(source, out flags, page, subifd, n, autorotate, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to tiff file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Tiffsave(filename, compression: string, q: int, predictor: string, profile: string, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, bitdepth: int, resunit: string, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: string, level: int, subifd: bool, lossless: bool, depth: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="compression">Compression for this file.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="predictor">Compression prediction.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="tile">Write a tiled tiff.</param>
        /// <param name="tileWidth">Tile width in pixels.</param>
        /// <param name="tileHeight">Tile height in pixels.</param>
        /// <param name="pyramid">Write a pyramidal tiff.</param>
        /// <param name="miniswhite">Use 0 for white in 1-bit images.</param>
        /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
        /// <param name="resunit">Resolution unit.</param>
        /// <param name="xres">Horizontal resolution in pixels/mm.</param>
        /// <param name="yres">Vertical resolution in pixels/mm.</param>
        /// <param name="bigtiff">Write a bigtiff image.</param>
        /// <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
        /// <param name="regionShrink">Method to shrink regions.</param>
        /// <param name="level">ZSTD compression level.</param>
        /// <param name="subifd">Save pyr layers as sub-IFDs.</param>
        /// <param name="lossless">Enable WEBP lossless mode.</param>
        /// <param name="depth">Pyramid depth.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Tiffsave(string filename, string compression = null, int? q = null, string predictor = null, string profile = null, bool? tile = null, int? tileWidth = null, int? tileHeight = null, bool? pyramid = null, bool? miniswhite = null, int? bitdepth = null, string resunit = null, double? xres = null, double? yres = null, bool? bigtiff = null, bool? properties = null, string regionShrink = null, int? level = null, bool? subifd = null, bool? lossless = null, string depth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (compression != null)
            {
                options.Add(nameof(compression), compression);
            }

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (predictor != null)
            {
                options.Add(nameof(predictor), predictor);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (tile.HasValue)
            {
                options.Add(nameof(tile), tile);
            }

            if (tileWidth.HasValue)
            {
                options.Add("tile_width", tileWidth);
            }

            if (tileHeight.HasValue)
            {
                options.Add("tile_height", tileHeight);
            }

            if (pyramid.HasValue)
            {
                options.Add(nameof(pyramid), pyramid);
            }

            if (miniswhite.HasValue)
            {
                options.Add(nameof(miniswhite), miniswhite);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (resunit != null)
            {
                options.Add(nameof(resunit), resunit);
            }

            if (xres.HasValue)
            {
                options.Add(nameof(xres), xres);
            }

            if (yres.HasValue)
            {
                options.Add(nameof(yres), yres);
            }

            if (bigtiff.HasValue)
            {
                options.Add(nameof(bigtiff), bigtiff);
            }

            if (properties.HasValue)
            {
                options.Add(nameof(properties), properties);
            }

            if (regionShrink != null)
            {
                options.Add("region_shrink", regionShrink);
            }

            if (level.HasValue)
            {
                options.Add(nameof(level), level);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (depth != null)
            {
                options.Add(nameof(depth), depth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("tiffsave", options, filename);
        }

        /// <summary>
        /// Save image to tiff buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.TiffsaveBuffer(compression: string, q: int, predictor: string, profile: string, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, bitdepth: int, resunit: string, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: string, level: int, subifd: bool, lossless: bool, depth: string, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="compression">Compression for this file.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="predictor">Compression prediction.</param>
        /// <param name="profile">ICC profile to embed.</param>
        /// <param name="tile">Write a tiled tiff.</param>
        /// <param name="tileWidth">Tile width in pixels.</param>
        /// <param name="tileHeight">Tile height in pixels.</param>
        /// <param name="pyramid">Write a pyramidal tiff.</param>
        /// <param name="miniswhite">Use 0 for white in 1-bit images.</param>
        /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
        /// <param name="resunit">Resolution unit.</param>
        /// <param name="xres">Horizontal resolution in pixels/mm.</param>
        /// <param name="yres">Vertical resolution in pixels/mm.</param>
        /// <param name="bigtiff">Write a bigtiff image.</param>
        /// <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
        /// <param name="regionShrink">Method to shrink regions.</param>
        /// <param name="level">ZSTD compression level.</param>
        /// <param name="subifd">Save pyr layers as sub-IFDs.</param>
        /// <param name="lossless">Enable WEBP lossless mode.</param>
        /// <param name="depth">Pyramid depth.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] TiffsaveBuffer(string compression = null, int? q = null, string predictor = null, string profile = null, bool? tile = null, int? tileWidth = null, int? tileHeight = null, bool? pyramid = null, bool? miniswhite = null, int? bitdepth = null, string resunit = null, double? xres = null, double? yres = null, bool? bigtiff = null, bool? properties = null, string regionShrink = null, int? level = null, bool? subifd = null, bool? lossless = null, string depth = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (compression != null)
            {
                options.Add(nameof(compression), compression);
            }

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (predictor != null)
            {
                options.Add(nameof(predictor), predictor);
            }

            if (profile != null)
            {
                options.Add(nameof(profile), profile);
            }

            if (tile.HasValue)
            {
                options.Add(nameof(tile), tile);
            }

            if (tileWidth.HasValue)
            {
                options.Add("tile_width", tileWidth);
            }

            if (tileHeight.HasValue)
            {
                options.Add("tile_height", tileHeight);
            }

            if (pyramid.HasValue)
            {
                options.Add(nameof(pyramid), pyramid);
            }

            if (miniswhite.HasValue)
            {
                options.Add(nameof(miniswhite), miniswhite);
            }

            if (bitdepth.HasValue)
            {
                options.Add(nameof(bitdepth), bitdepth);
            }

            if (resunit != null)
            {
                options.Add(nameof(resunit), resunit);
            }

            if (xres.HasValue)
            {
                options.Add(nameof(xres), xres);
            }

            if (yres.HasValue)
            {
                options.Add(nameof(yres), yres);
            }

            if (bigtiff.HasValue)
            {
                options.Add(nameof(bigtiff), bigtiff);
            }

            if (properties.HasValue)
            {
                options.Add(nameof(properties), properties);
            }

            if (regionShrink != null)
            {
                options.Add("region_shrink", regionShrink);
            }

            if (level.HasValue)
            {
                options.Add(nameof(level), level);
            }

            if (subifd.HasValue)
            {
                options.Add(nameof(subifd), subifd);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (depth != null)
            {
                options.Add(nameof(depth), depth);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("tiffsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Cache an image as a set of tiles.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Tilecache(tileWidth: int, tileHeight: int, maxTiles: int, access: string, threaded: bool, persistent: bool);
        /// </code>
        /// </example>
        /// <param name="tileWidth">Tile width in pixels.</param>
        /// <param name="tileHeight">Tile height in pixels.</param>
        /// <param name="maxTiles">Maximum number of tiles to cache.</param>
        /// <param name="access">Expected access pattern.</param>
        /// <param name="threaded">Allow threaded access.</param>
        /// <param name="persistent">Keep cache between evaluations.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Tilecache(int? tileWidth = null, int? tileHeight = null, int? maxTiles = null, string access = null, bool? threaded = null, bool? persistent = null)
        {
            var options = new VOption();

            if (tileWidth.HasValue)
            {
                options.Add("tile_width", tileWidth);
            }

            if (tileHeight.HasValue)
            {
                options.Add("tile_height", tileHeight);
            }

            if (maxTiles.HasValue)
            {
                options.Add("max_tiles", maxTiles);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (threaded.HasValue)
            {
                options.Add(nameof(threaded), threaded);
            }

            if (persistent.HasValue)
            {
                options.Add(nameof(persistent), persistent);
            }

            return this.Call("tilecache", options) as Image;
        }

        /// <summary>
        /// Build a look-up table.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Tonelut(inMax: int, outMax: int, lb: double, lw: double, ps: double, pm: double, ph: double, s: double, m: double, h: double);
        /// </code>
        /// </example>
        /// <param name="inMax">Size of LUT to build.</param>
        /// <param name="outMax">Maximum value in output LUT.</param>
        /// <param name="lb">Lowest value in output.</param>
        /// <param name="lw">Highest value in output.</param>
        /// <param name="ps">Position of shadow.</param>
        /// <param name="pm">Position of mid-tones.</param>
        /// <param name="ph">Position of highlights.</param>
        /// <param name="s">Adjust shadows by this much.</param>
        /// <param name="m">Adjust mid-tones by this much.</param>
        /// <param name="h">Adjust highlights by this much.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Tonelut(int? inMax = null, int? outMax = null, double? lb = null, double? lw = null, double? ps = null, double? pm = null, double? ph = null, double? s = null, double? m = null, double? h = null)
        {
            var options = new VOption();

            if (inMax.HasValue)
            {
                options.Add("in_max", inMax);
            }

            if (outMax.HasValue)
            {
                options.Add("out_max", outMax);
            }

            if (lb.HasValue)
            {
                options.Add("Lb", lb);
            }

            if (lw.HasValue)
            {
                options.Add("Lw", lw);
            }

            if (ps.HasValue)
            {
                options.Add("Ps", ps);
            }

            if (pm.HasValue)
            {
                options.Add("Pm", pm);
            }

            if (ph.HasValue)
            {
                options.Add("Ph", ph);
            }

            if (s.HasValue)
            {
                options.Add("S", s);
            }

            if (m.HasValue)
            {
                options.Add("M", m);
            }

            if (h.HasValue)
            {
                options.Add("H", h);
            }

            return Operation.Call("tonelut", options) as Image;
        }

        /// <summary>
        /// Transpose3d an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Transpose3d(pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="pageHeight">Height of each input page.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Transpose3d(int? pageHeight = null)
        {
            var options = new VOption();

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("transpose3d", options) as Image;
        }

        /// <summary>
        /// Unpremultiply image alpha.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Unpremultiply(maxAlpha: double, alphaBand: int);
        /// </code>
        /// </example>
        /// <param name="maxAlpha">Maximum value of alpha channel.</param>
        /// <param name="alphaBand">Unpremultiply with this alpha.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Unpremultiply(double? maxAlpha = null, int? alphaBand = null)
        {
            var options = new VOption();

            if (maxAlpha.HasValue)
            {
                options.Add("max_alpha", maxAlpha);
            }

            if (alphaBand.HasValue)
            {
                options.Add("alpha_band", alphaBand);
            }

            return this.Call("unpremultiply", options) as Image;
        }

        /// <summary>
        /// Load vips from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Vipsload(filename, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Vipsload(string filename, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("vipsload", options, filename) as Image;
        }

        /// <summary>
        /// Load vips from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Vipsload(filename, out var flags, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Vipsload(string filename, out int flags, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("vipsload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Save image to vips file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Vipssave(filename, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Vipssave(string filename, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("vipssave", options, filename);
        }

        /// <summary>
        /// Load webp from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Webpload(filename, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Webpload(string filename, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("webpload", options, filename) as Image;
        }

        /// <summary>
        /// Load webp from file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Webpload(filename, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Webpload(string filename, out int flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("webpload", options, filename) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load webp from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.WebploadBuffer(buffer, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image WebploadBuffer(byte[] buffer, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("webpload_buffer", options, buffer) as Image;
        }

        /// <summary>
        /// Load webp from buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.WebploadBuffer(buffer, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="buffer">Buffer to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image WebploadBuffer(byte[] buffer, out int flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("webpload_buffer", options, buffer) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load webp from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.WebploadSource(source, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image WebploadSource(Source source, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            return Operation.Call("webpload_source", options, source) as Image;
        }

        /// <summary>
        /// Load webp from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.WebploadStream(stream, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image WebploadStream(Stream stream, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = WebploadSource(source, page, n, scale, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Load webp from source.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.WebploadSource(source, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="source">Source to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image WebploadSource(Source source, out int flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var options = new VOption();

            if (page.HasValue)
            {
                options.Add(nameof(page), page);
            }

            if (n.HasValue)
            {
                options.Add(nameof(n), n);
            }

            if (scale.HasValue)
            {
                options.Add(nameof(scale), scale);
            }

            if (memory.HasValue)
            {
                options.Add(nameof(memory), memory);
            }

            if (access != null)
            {
                options.Add(nameof(access), access);
            }

            if (fail.HasValue)
            {
                options.Add(nameof(fail), fail);
            }

            options.Add("flags", true);

            var results = Operation.Call("webpload_source", options, source) as object[];
            var finalResult = results?[0] as Image;
            var opts = results?[1] as VOption;
            flags = opts?["flags"] is int out1 ? out1 : 0;

            return finalResult;
        }

        /// <summary>
        /// Load webp from stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.WebploadStream(stream, out var flags, page: int, n: int, scale: double, memory: bool, access: string, fail: bool);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to load from.</param>
        /// <param name="flags">Flags for this file.</param>
        /// <param name="page">Load this page from the file.</param>
        /// <param name="n">Load this many pages.</param>
        /// <param name="scale">Scale factor on load.</param>
        /// <param name="memory">Force open via memory.</param>
        /// <param name="access">Required access pattern for this file.</param>
        /// <param name="fail">Fail on first error.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image WebploadStream(Stream stream, out int flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, string access = null, bool? fail = null)
        {
            var source = SourceStream.NewFromStream(stream);
            var image = WebploadSource(source, out flags, page, n, scale, memory, access, fail);

            image.OnUnref += () => source.Dispose();

            return image;
        }

        /// <summary>
        /// Save image to webp file.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.Webpsave(filename, q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="filename">Filename to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">enable lossless compression.</param>
        /// <param name="preset">Preset for lossy compression.</param>
        /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
        /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
        /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
        /// <param name="minSize">Optimise for minium size.</param>
        /// <param name="kmin">Minimum number of frames between key frames.</param>
        /// <param name="kmax">Maximum number of frames between key frames.</param>
        /// <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void Webpsave(string filename, int? q = null, bool? lossless = null, string preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? reductionEffort = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (preset != null)
            {
                options.Add(nameof(preset), preset);
            }

            if (smartSubsample.HasValue)
            {
                options.Add("smart_subsample", smartSubsample);
            }

            if (nearLossless.HasValue)
            {
                options.Add("near_lossless", nearLossless);
            }

            if (alphaQ.HasValue)
            {
                options.Add("alpha_q", alphaQ);
            }

            if (minSize.HasValue)
            {
                options.Add("min_size", minSize);
            }

            if (kmin.HasValue)
            {
                options.Add(nameof(kmin), kmin);
            }

            if (kmax.HasValue)
            {
                options.Add(nameof(kmax), kmax);
            }

            if (reductionEffort.HasValue)
            {
                options.Add("reduction_effort", reductionEffort);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("webpsave", options, filename);
        }

        /// <summary>
        /// Save image to webp buffer.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// byte[] buffer = in.WebpsaveBuffer(q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">enable lossless compression.</param>
        /// <param name="preset">Preset for lossy compression.</param>
        /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
        /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
        /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
        /// <param name="minSize">Optimise for minium size.</param>
        /// <param name="kmin">Minimum number of frames between key frames.</param>
        /// <param name="kmax">Maximum number of frames between key frames.</param>
        /// <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        /// <returns>An array of bytes.</returns>
        public byte[] WebpsaveBuffer(int? q = null, bool? lossless = null, string preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? reductionEffort = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (preset != null)
            {
                options.Add(nameof(preset), preset);
            }

            if (smartSubsample.HasValue)
            {
                options.Add("smart_subsample", smartSubsample);
            }

            if (nearLossless.HasValue)
            {
                options.Add("near_lossless", nearLossless);
            }

            if (alphaQ.HasValue)
            {
                options.Add("alpha_q", alphaQ);
            }

            if (minSize.HasValue)
            {
                options.Add("min_size", minSize);
            }

            if (kmin.HasValue)
            {
                options.Add(nameof(kmin), kmin);
            }

            if (kmax.HasValue)
            {
                options.Add(nameof(kmax), kmax);
            }

            if (reductionEffort.HasValue)
            {
                options.Add("reduction_effort", reductionEffort);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            return this.Call("webpsave_buffer", options) as byte[];
        }

        /// <summary>
        /// Save image to webp target.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.WebpsaveTarget(target, q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="target">Target to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">enable lossless compression.</param>
        /// <param name="preset">Preset for lossy compression.</param>
        /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
        /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
        /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
        /// <param name="minSize">Optimise for minium size.</param>
        /// <param name="kmin">Minimum number of frames between key frames.</param>
        /// <param name="kmax">Maximum number of frames between key frames.</param>
        /// <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void WebpsaveTarget(Target target, int? q = null, bool? lossless = null, string preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? reductionEffort = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            var options = new VOption();

            if (q.HasValue)
            {
                options.Add("Q", q);
            }

            if (lossless.HasValue)
            {
                options.Add(nameof(lossless), lossless);
            }

            if (preset != null)
            {
                options.Add(nameof(preset), preset);
            }

            if (smartSubsample.HasValue)
            {
                options.Add("smart_subsample", smartSubsample);
            }

            if (nearLossless.HasValue)
            {
                options.Add("near_lossless", nearLossless);
            }

            if (alphaQ.HasValue)
            {
                options.Add("alpha_q", alphaQ);
            }

            if (minSize.HasValue)
            {
                options.Add("min_size", minSize);
            }

            if (kmin.HasValue)
            {
                options.Add(nameof(kmin), kmin);
            }

            if (kmax.HasValue)
            {
                options.Add(nameof(kmax), kmax);
            }

            if (reductionEffort.HasValue)
            {
                options.Add("reduction_effort", reductionEffort);
            }

            if (strip.HasValue)
            {
                options.Add(nameof(strip), strip);
            }

            if (background != null && background.Length > 0)
            {
                options.Add(nameof(background), background);
            }

            if (pageHeight.HasValue)
            {
                options.Add("page_height", pageHeight);
            }

            this.Call("webpsave_target", options, target);
        }

        /// <summary>
        /// Save image to webp stream.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// in.WebpsaveStream(stream, q: int, lossless: bool, preset: string, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, reductionEffort: int, strip: bool, background: double[], pageHeight: int);
        /// </code>
        /// </example>
        /// <param name="stream">Stream to save to.</param>
        /// <param name="q">Q factor.</param>
        /// <param name="lossless">enable lossless compression.</param>
        /// <param name="preset">Preset for lossy compression.</param>
        /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
        /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
        /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
        /// <param name="minSize">Optimise for minium size.</param>
        /// <param name="kmin">Minimum number of frames between key frames.</param>
        /// <param name="kmax">Maximum number of frames between key frames.</param>
        /// <param name="reductionEffort">Level of CPU effort to reduce file size.</param>
        /// <param name="strip">Strip all metadata from image.</param>
        /// <param name="background">Background value.</param>
        /// <param name="pageHeight">Set page height for multipage save.</param>
        public void WebpsaveStream(Stream stream, int? q = null, bool? lossless = null, string preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? reductionEffort = null, bool? strip = null, double[] background = null, int? pageHeight = null)
        {
            using (var target = TargetStream.NewFromStream(stream))
            {
                WebpsaveTarget(target, q, lossless, preset, smartSubsample, nearLossless, alphaQ, minSize, kmin, kmax, reductionEffort, strip, background, pageHeight);
            }
        }

        /// <summary>
        /// Make a worley noise image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Worley(width, height, cellSize: int);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="cellSize">Size of Worley cells.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Worley(int width, int height, int? cellSize = null)
        {
            var options = new VOption();

            if (cellSize.HasValue)
            {
                options.Add("cell_size", cellSize);
            }

            return Operation.Call("worley", options, width, height) as Image;
        }

        /// <summary>
        /// Wrap image origin.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Wrap(x: int, y: int);
        /// </code>
        /// </example>
        /// <param name="x">Left edge of input in output.</param>
        /// <param name="y">Top edge of input in output.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Wrap(int? x = null, int? y = null)
        {
            var options = new VOption();

            if (x.HasValue)
            {
                options.Add(nameof(x), x);
            }

            if (y.HasValue)
            {
                options.Add(nameof(y), y);
            }

            return this.Call("wrap", options) as Image;
        }

        /// <summary>
        /// Make an image where pixel values are coordinates.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Xyz(width, height, csize: int, dsize: int, esize: int);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="csize">Size of third dimension.</param>
        /// <param name="dsize">Size of fourth dimension.</param>
        /// <param name="esize">Size of fifth dimension.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Xyz(int width, int height, int? csize = null, int? dsize = null, int? esize = null)
        {
            var options = new VOption();

            if (csize.HasValue)
            {
                options.Add(nameof(csize), csize);
            }

            if (dsize.HasValue)
            {
                options.Add(nameof(dsize), dsize);
            }

            if (esize.HasValue)
            {
                options.Add(nameof(esize), esize);
            }

            return Operation.Call("xyz", options, width, height) as Image;
        }

        /// <summary>
        /// Transform XYZ to CMYK.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.XYZ2CMYK();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image XYZ2CMYK()
        {
            return this.Call("XYZ2CMYK") as Image;
        }

        /// <summary>
        /// Transform XYZ to Lab.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.XYZ2Lab(temp: double[]);
        /// </code>
        /// </example>
        /// <param name="temp">Colour temperature.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image XYZ2Lab(double[] temp = null)
        {
            var options = new VOption();

            if (temp != null && temp.Length > 0)
            {
                options.Add(nameof(temp), temp);
            }

            return this.Call("XYZ2Lab", options) as Image;
        }

        /// <summary>
        /// Transform XYZ to scRGB.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.XYZ2scRGB();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image XYZ2scRGB()
        {
            return this.Call("XYZ2scRGB") as Image;
        }

        /// <summary>
        /// Transform XYZ to Yxy.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.XYZ2Yxy();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image XYZ2Yxy()
        {
            return this.Call("XYZ2Yxy") as Image;
        }

        /// <summary>
        /// Transform Yxy to XYZ.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = in.Yxy2XYZ();
        /// </code>
        /// </example>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Yxy2XYZ()
        {
            return this.Call("Yxy2XYZ") as Image;
        }

        /// <summary>
        /// Make a zone plate.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = NetVips.Image.Zone(width, height, uchar: bool);
        /// </code>
        /// </example>
        /// <param name="width">Image width in pixels.</param>
        /// <param name="height">Image height in pixels.</param>
        /// <param name="uchar">Output an unsigned char image.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public static Image Zone(int width, int height, bool? uchar = null)
        {
            var options = new VOption();

            if (uchar.HasValue)
            {
                options.Add(nameof(uchar), uchar);
            }

            return Operation.Call("zone", options, width, height) as Image;
        }

        /// <summary>
        /// Zoom an image.
        /// </summary>
        /// <example>
        /// <code language="lang-csharp">
        /// Image @out = input.Zoom(xfac, yfac);
        /// </code>
        /// </example>
        /// <param name="xfac">Horizontal zoom factor.</param>
        /// <param name="yfac">Vertical zoom factor.</param>
        /// <returns>A new <see cref="Image"/>.</returns>
        public Image Zoom(int xfac, int yfac)
        {
            return this.Call("zoom", xfac, yfac) as Image;
        }

        #endregion

        #region auto-generated properties

        /// <summary>
        /// Image width in pixels
        /// </summary>
        public int Width => (int)Get("width");

        /// <summary>
        /// Image height in pixels
        /// </summary>
        public int Height => (int)Get("height");

        /// <summary>
        /// Number of bands in image
        /// </summary>
        public int Bands => (int)Get("bands");

        /// <summary>
        /// Pixel format in image
        /// </summary>
        public string Format => (string)Get("format");

        /// <summary>
        /// Pixel coding
        /// </summary>
        public string Coding => (string)Get("coding");

        /// <summary>
        /// Pixel interpretation
        /// </summary>
        public string Interpretation => (string)Get("interpretation");

        /// <summary>
        /// Horizontal offset of origin
        /// </summary>
        public int Xoffset => (int)Get("xoffset");

        /// <summary>
        /// Vertical offset of origin
        /// </summary>
        public int Yoffset => (int)Get("yoffset");

        /// <summary>
        /// Horizontal resolution in pixels/mm
        /// </summary>
        public double Xres => (double)Get("xres");

        /// <summary>
        /// Vertical resolution in pixels/mm
        /// </summary>
        public double Yres => (double)Get("yres");

        /// <summary>
        /// Image filename
        /// </summary>
        public string Filename => (string)Get("filename");

        #endregion
    }
}
